<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP headers 之 host, referer, origin]]></title>
    <url>%2F2019%2F09%2F27%2FhttpHeaders%2F</url>
    <content type="text"><![CDATA[还在对 HTTP 头中的 host, referer, origin 傻傻分不清吗。今天我们就来弄清楚他们的区别及用途。 1. host1.1 定义Host 请求头指明了请求服务器的域名/IP地址和端口号。 组成：域名+端口号 例子：test.com:1998 如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个HTTP的URL会自动使用80端口）。 HTTP/1.1 的所有请求报文中必须包含一个 Host 头字段。如果一个 HTTP/1.1 请求缺少 Host 头字段或者设置了超过一个的 Host 头字段，一个400（Bad Request）状态码会被返回。 1.2 用途我们知道，不同的域名通过 A 记录或者 CNAME 方式可以连接都同一个 IP 下，同一个 IP 也可以设置多个不同站点，那么访问不同的域名都转发到同一 IP ，怎么区分这些不同的站点呢，就是用的 Host 字段。这样每次访问都会根据不同的 Host 的信息请求到不同的站点上面。 简而言之，就是主要应用在虚拟主机技术上。虚拟主机（virtual hosting）即共享主机（shared web hosting），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。 比如说有一台 ip 地址为 11.11.11.11 的服务器，在这台服务器上部署着淘宝、京东、拼多多的网站，并且配置了三个虚拟主机：a.com, b.com, c.com, 这三个域名都指向 11.11.11.11。 当我们访问 c.com 的网站时，看到的是拼多多的页面而不是淘宝和京东的页面，原因就是 Host 请求头决定着访问哪个虚拟主机。 2. referer2.1 定义：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。 组成：协议+域名+端口号+路径+参数（注意，不包含 hash值） 例子：http://test.com:1998/home 需要注意的是 referer 实际上是 “referrer” 误拼写。 在以下几种情况下，Referer 不会被发送： 来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI； 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）； 直接输入网址或通过浏览器书签访问； 使用 JavaScript 的 Location.href 或者是 Location.replace()； 使用 html5 中 noreferrer 2.2 用途服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等，还有个常见的用途是图片防盗链。 防盗链原理是：当用户访问网页时，referer就是前一个网页的URL；如果是图片的话，通常指的就是图片所在的网页。当浏览器向服务器发送请求时，referer就自动携带在HTTP请求头了。图片服务器根据这个请求头判断，如果 referer 不是自己的服务器，就将其拦截。 比如说掘金的图片： https://user-gold-cdn.xitu.io/2019/9/23/16d5d0e6314aac90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 直接在浏览器中打开是可以访问的，因为此时 referer 不会被发送。 而如果把图片放到自己的网站下，是看不到正常图片的。 因为 referer 不在掘金白名单里。（掘金、微信等客户端能看到，因为在掘金白名单里） 那么如何破解盗链呢，常用的是用一个服务器程序作为代理爬虫，服务器爬虫可以自由地设置请求头。 但是 referrer 存在很多问题。比如说在请求外部网站的时候，携带着 url 的很多参数信息，而这些信息实际上是隐私的，所以存在一定的隐私暴露风险。下面的 origin 就不存在这种隐私问题。 3. origin3.1 定义请求首部字段 Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。除了不包含路径信息，该字段与 Referer 首部字段相似。 该首部用于 CORS 请求或者 POST 请求。 组成：协议+域名+端口号 注意：只有跨域请求（可以看到 response 有对应的 header：Access-Control-Allow-Origin），或者同域时发送post请求，才会携带origin请求头。如果浏览器不能获取请求源，那么 origin 满足上面情况也会携带，不过其值为null。 而referer不论何种情况下，只要浏览器能获取到请求源都会携带。如果浏览器如果不能获取请求源，那么请求头中不会携带referer。 3.2 用途用于 CORS: 当我们的浏览器发出跨站请求时，服务器会校验当前请求是不是来自被允许的站点。服务器就是通过 Origin 字段的值来进行判断。 参考 host、referer和origin的区别 HTTP Headers]]></content>
      <categories>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js中版本号的比较]]></title>
    <url>%2F2019%2F09%2F17%2FjsVersion%2F</url>
    <content type="text"><![CDATA[1. 背景在开发过程中，我们常常需要比较两个版本号的大小，来做一些特殊处理，今天我们就来实现此功能。 假设版本号为非空字符串，并且只包含数字和 . 字符。这种情形下比较两个版本号 version1 和 version2，如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 2. 思路将版本号字符串拆分成只含数字的数组，依次比较数字大小。要注意的是比对时不能简单的循环判断有一位大或者小就跳出循环，得一位一位比较；而且应该从大位到小位依次循环比对，到第一个不相同点（包括大于和小于）就跳出循环。如果循环全部走完，则根据版本号长度再次判断。还有注意下面这种特殊情形：1 和 1.0、1.0.0、1.00.0 的版本是一样的。 3. 代码123456789101112131415161718192021222324252627282930313233function compareVersion(version1, version2) &#123; const arr1 = version1.split('.') const arr2 = version2.split('.') const length1 = arr1.length const length2 = arr2.length const minlength = Math.min(length1, length2) let i = 0 for (i ; i &lt; minlength; i++) &#123; let a = parseInt(arr1[i]) let b = parseInt(arr2[i]) if (a &gt; b) &#123; return 1 &#125; else if (a &lt; b) &#123; return -1 &#125; &#125; if (length1 &gt; length2) &#123; for(let j = i; j &lt; length1; j++) &#123; if (parseInt(arr1[j]) != 0) &#123; return 1 &#125; &#125; return 0 &#125; else if (length1 &lt; length2) &#123; for(let j = i; j &lt; length2; j++) &#123; if (parseInt(arr2[j]) != 0) &#123; return -1 &#125; &#125; return 0 &#125; return 0&#125; 来测试下： 123compareVersion('1.2.4', '1.1.5') // 1compareVersion('1.2', '1.10.5') // -1compareVersion('1.00.03', '1.0.03') // 0 这下子就可以愉悦地比较版本号啦。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小程序登录流程全解析]]></title>
    <url>%2F2019%2F09%2F16%2FminiProgram-login%2F</url>
    <content type="text"><![CDATA[用户登录是一个系统的必备功能。而小程序的登录流程和Web端又有一些不同，主要是要与微信服务器进行通信验证。下面我们就来看下小程序具体的登录流程。 1. 登录流程小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。 2. 登录逻辑： 调用 wx.login() 获取 临时登录凭证 code，有效期为 5分钟；（临时登录凭证 code 只能使用一次） 将临时 code 传到我们的后端，后端调用 auth.code2Session 接口，换取用户唯一标识 OpenID 和 会话密钥 session_key；（ openid 是用户唯一标识，session_key 能保证当前用户进行会话操作的有效性） 注意：获取 session_key 出于安全性的考虑，要在后端调用。如果我们在前端通过 request 调用此接口，就不可避免的需要将我们小程序的appid 、secret 和服务端下发的 session_key 暴露在外部，会给我们的业务安全带来极大的风险。 session_key 拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者需要调用 wx.checkSession 接口检测当前用户登录态是否有效。 后端自定义新的密钥并关联返回的 session_key 和 openid，将新的密钥返给前端，前端将其存储在 storage 中。（会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥，所以要定义新的密钥）。 之所以存在storage中，是因为小程序没有 cookie，相应的后端 set-cookie 在小程序中不起作用。 前端发送请求的时候，带着密钥，后端根据密钥识别用户身份，返回数据。 3. 遇到的问题在接口报401错误时，对其做登录处理，登录成功后再次调用接口。这种情况下，多接口并行就会出现问题。因为多接口都会调 wx.login 获取 code 后再调后端的登录接口，而登录凭证 code 只能使用一次，这时候后端对多接口就会接收到不同的 code，返回的自定义密钥就会有多个，不能保持统一。 处理的方案是后端在一定时间内对用户自定义登录态做缓存。接口调 wx.login 获取 code 后再调后端的登录接口时，判断后端缓存中有无此用户，如果没有，返回新的密钥，如果缓存中存在此用户并在缓存有效时间内，就查找并返回之前的密钥。 4. 具体代码checkSession: 检查登录态是否过期。通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687checkSession: function () &#123; return wx.pro.checkSession().then(res =&gt; &#123; return Promise.resolve('result1') &#125;).catch(err =&gt; &#123; return this.login() &#125;)&#125;,login: function () &#123; return wx.pro.login().then(res =&gt; &#123; return Promise.resolve(res.code) &#125;).then(res =&gt; &#123; return this.getRequest(&#123; method: 'POST', url: "***/login", data: &#123; code: res &#125; &#125;) &#125;).then(res =&gt; &#123; let Cookie = res &amp;&amp; res.header &amp;&amp; res.header['Set-Cookie'] || ''; Cookie = this.getCookie('cookie-key', Cookie) wx.setStorageSync('Cookie', Cookie) this.globalData.Cookie = Cookie return Promise.resolve('result2') &#125;).catch(err =&gt; &#123; console.log('loginErr', err) &#125;)&#125;,getCookie(name, cookie) &#123; let arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)"); return (arr = cookie.match(reg)) ? unescape(arr[2]) : null;&#125;,getRequest: function (data, tryNum = 1) &#123; let header = Object.assign(&#123; "Content-Type": "application/x-www-form-urlencoded", &#125;, data.header) if (data.url !== '**/login') &#123; header = Object.assign(header, &#123; "Cookie": `cookie-key=$&#123;this.globalData.Cookie&#125;` &#125;) &#125; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: (data.mode !== 'debug' ? Env_config[envObj.env].api : '') + data.url, method: data.method || "GET", header: header, data: data.data, success: (res) =&gt; &#123; if (res &amp;&amp; res.statusCode === 200) &#123; resolve(res) &#125; else if (res.statusCode === 401) &#123; wx.showToast(&#123; title: '登录失效，请重新登录', icon: 'none', &#125;) if (tryNum &gt; maxTryNum) return null return this.login().then(res =&gt; &#123; return this.getRequest(data, ++tryNum) &#125;).then(res =&gt; resolve(res)) .catch(err =&gt; &#123; reject(err) &#125;) &#125; else &#123; setTimeout(() =&gt; &#123; wx.showToast(&#123; title: res &amp;&amp; res.data &amp;&amp; res.data.msg || '服务异常，请稍后重试', icon: 'none' &#125;) &#125;, 0) reject(res) &#125; &#125;, fail: (err) =&gt; &#123; setTimeout(() =&gt; &#123; wx.showToast(&#123; title: res &amp;&amp; res.data &amp;&amp; res.data.msg || '服务异常，请稍后重试', icon: 'none' &#125;) &#125;, 0) reject(err) &#125; &#125;) &#125;)&#125;, 在页面中的用法也很简单： 12345onLoad: function (options) &#123; app.checkSession().then(res =&gt; &#123; this.otherMethods() &#125;)&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小程序性能优化技巧]]></title>
    <url>%2F2019%2F08%2F09%2FminiProgramPerformance%2F</url>
    <content type="text"><![CDATA[网页性能优化是前端一个老生常谈的话题，但微信小程序因为双线程的架构设计，跟传统 Web 页面不太一样。所以，今天来探究下微信小程序内的性能优化问题。 首先，要问大家一个问题：从打开微信小程序到首页展示在大家面前，要经过哪些过程？（可以类比与前端另一个常见问题：Web 页面从输入 url 到页面展示具体经过了哪些过程） 1. 启动过程相信大家对 Web 页面的展现过程非常清楚。那么小程序呢，简要地说，小程序要历经下面几个启动过程： 小程序初始化： 微信初始化小程序环境：包括 Js 引擎和 WebView 进行初始化，并注入公共基础库。 这步是微信做的，在用户打开小程序之前就已经准备好了，是小程序运行环境预加载。 下载小程序代码包 对小程序业务代码包进行下载：下载的不是小程序的源代码，而是编译、压缩、打包之后的代码。 加载小程序代码包对下载完成对代码包进行注入执行。此时，app.js、页面所在的 Js 文件和所有其他被 require 的 Js 文件会被自动执行一次，小程序基础库会完成所有页面的注册。 初始化小程序首页 拉取数据，从逻辑层传递到视图层，进行渲染。 2. 性能优化既然清楚了小程序的启动过程，那我们就可以针对其中的每一个环节进行性能分析和优化。 2.1 小程序初始化环节由于这个环节是微信执行的，属于小程序底层的执行耗时，所以我们开发者无法操控。已知的是：iOS 初始化比 Android 快一些。 2.2 下载和加载环节一般来说：下载环节是耗时比较长的环节。对低于 1MB 的代码包，其下载时间可以控制在 929ms（iOS）、1500ms（Android）内。那么提升下载性能最关键的一点是：控制包的大小。 常见的控制代码包大小的方法如下： 精简代码，清除无用代码 减少在代码包中直接嵌入的资源文件 图片放在cdn，使用适当的图片格式 如果小程序比较复杂，优化后的代码总量仍然较大，此时可以采用分包加载的方式进行优化。 其原理是：一般情况下，小程序的代码将打包在一起，在小程序启动时一次性下载完成。采用分包时，小程序的代码包可以被划分为几个：一个是“主包”，包含小程序启动时会马上打开的页面代码和相关资源；其余是“分包”，包含其余的代码和资源。这样，小程序启动时，只需要先将主包下载完成，就可以立刻启动小程序。这样就可以显著降低小程序代码包的下载时间。 但是这个时候又出现了另一个问题，在我们访问分包页面时，需要先下载完分包代码，才能打开分包页面，这是能感觉到到明显卡顿，体验也是比较差的。 我们可以通过配置 preloadRule 进行分包预加载：打开首页，加载完主包后，静默加载其他分包。 除了普通分包方案，小程序还有独立分包的方案。独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。我们可以把它用于一些比较独立的页面，比如活动页等。 2.3 初始化首页环节到了首屏渲染这个环节，有以下的几个优化建议： 提前请求：在页面 onLoad 阶段就可以发起异步请求，不用等页面 ready。如果能在前置页面点击跳转时预请求当前页的核心异步请求，效果会更好； 善用缓存：对一些变动频率很低的异步数据进行缓存，下次启动时可以直接利用； 优化交互：在首屏渲染的期间，利用 loading 效果或展示骨架图，来缓解用户等待的焦虑。 其实，页面初始化的时间大致由页面初始数据通信时间和初始渲染时间两部分构成。其中，数据通信的时间指数据从逻辑层开始组织数据到视图层完全接收完毕的时间，数据量小于 64KB 时总时长可以控制在30ms内。传输时间与数据量大体上呈现正相关关系，传输过大的数据将使这一时间显著增加。因而减少传输数据量是降低数据传输时间的有效方式。 初始渲染完毕后，视图层可以在开发者调用setData后执行界面更新。 2.4 setData 优化2.4.1 setData 的工作原理与传统的浏览器 Web 页面最大区别在于，小程序的是基于 双线程 模型：在这种架构中，视图层使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。 两者都是独立的模块，并不具备数据直接共享的通道。视图层和逻辑层的数据传输，要由 Native 的 JSBrigde 做中转。 小程序通过 setData 更新数据到视图改变，完整的流程如下： 调用 setData 方法; 逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，将待传输数据转换成字符串并拼接到特定的JS脚本, 并通过 evaluateJavascript 执行脚本将数据传输到渲染层。 渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。 WebView 线程开始执行渲染时，将 data 和 setData 数据套用在WXML 片段上，得到一个新节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。最后，将 setData 数据合并到 data 中，并用新节点树替换旧节点树，用于下一次重渲染。 2.4.2 setData 注意事项如上文所说：一次 setData 带来两次开销：通信的开销 + WebView 更新的开销。setData 是小程序开发使用最频繁的 API 之一，也是最容易引发性能问题的。 所以使用时需要注意以下几点： 与界面渲染无关的数据最好不要设置在 data 中，可以考虑设置在 page 对象的其他字段下； 12345678910this.setData(&#123; a: &apos;与渲染有关的字符串&apos;, b: &apos;与渲染无关的字符串&apos;&#125;) // 可以优化为this.setData(&#123; a: &apos;与渲染有关的字符串&apos;, &#125;)this.b = &apos;与渲染无关的字符串&apos; 不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用； 1234this.setData(&#123; a: 1 &#125;)this.setData(&#123; b: 2 &#125;)// 可优化为this.setData(&#123; a: 1, b: 2 &#125;) 当需要在频繁触发的用户事件(如 PageScroll 、 Resize 事件)中调用 setData ，合理的利用函数防抖(debounce) 和 函数节流(throttle) 。 还可以自己设计一个 `diff` 算法，重新对 setData 进行封装，使得在 `setData` 执行之前，让待更新的数据与原 `data` 数据做 `diff `对比，如果一样则跳过执行更新。不少小程序框架都有其类似的封装。 列表局部更新 在更新列表的某一个数据时。不要用 setData 进行全部数据的刷新。查找对应 id 的那条数据的下标（index是不会改变的），用 setData 进行局部刷新。 123this.setData(&#123; `list[$&#123;index&#125;]` = newList[index]&#125;) 合理使用小程序组件 自定义组件的更新只在组件内部进行，不会影响页面其他元素。因为各个组件具有独立的逻辑空间、数据、样式环境及 setData 调用。 基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。 当这些自定义组件视图需要更新时，执行的是组件自己的 setData，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。 当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。 3. 分析工具其实性能优化最重要的是拿数据说话。但是现在小程序里没有完整成熟的定量的性能评测标准，目前有以下的分析工具可供参考： 性能 Trace 工具 微信 Andoid 6.5.10 开始，提供了 Trace 导出工具，开发者可以在开发者工具 Trace Panel 中使用该功能。 使用教程： https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tools.html 性能面板 从微信 6.5.8 开始，提供了性能面板让开发者了解小程序的性能。开发者可以在开发版小程序下打开性能面板。 打开方法：进入开发版小程序，进入右上角更多按钮，点击 显示性能窗口 加载性能监控 在小程序后台，我们可以看到加载性能监控。指标有三个： 启动总耗时 下载耗时 初次渲染耗时 总启动耗时 = 下载耗时 + 初次渲染耗时 + 其他耗时。 优化后可根据以上几个工具进行数据对比，来判断优化的效果。 主要参考来源： 微信小程序性能优化方案 微信小程序渲染性能调优]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序项目构建（二）]]></title>
    <url>%2F2019%2F07%2F25%2FminiProgram-start2%2F</url>
    <content type="text"><![CDATA[1. 多环境切换接上文：因为小程序只会存在一个预览版本，所以测试同学需要在其他环境测试时，都需要找到开发同学手动更改环境并重新发布体验版，非常之麻烦。可以利用微信摇一摇来实现环境的切换。 12345678910111213141516171819202122232425262728293031323334353637383940414243let Env_config = require('./index')let envList = Object.keys(Env_config)import envObj from './env'module.exports = function shake() &#123; let flag = true; wx.onAccelerometerChange(function (res) &#123; let pages = getCurrentPages() let page = pages[pages.length - 1].route // 只能在首页切换环境 if (page.indexOf('pages/index/index') === -1) return if (!flag) return if ((res.x &gt; 1) || (res.y &gt; 1) || (res.z &gt; 1)) &#123; flag = false; setTimeout(() =&gt; &#123; flag = true // 2s 内只触发一次 &#125;, 2000) wx.vibrateLong() wx.showModal(&#123; title: '摇一摇切环境', content: '选择环境', success(res) &#123; if (res.confirm) &#123; wx.showActionSheet(&#123; itemList: envList, success(res) &#123; changeEnv(envList[res.tapIndex]) &#125;, fail(res) &#123; console.log(res.errMsg) &#125; &#125;) &#125; &#125; &#125;) &#125; &#125;)&#125;function changeEnv(curEnv) &#123; envObj.env = curEnv&#125; app.js 也要进行处理，在线上环境不应该有切换环境的功能。 1234if (envObj.env !== 'production') &#123; const shake = require('./env/shake') shake()&#125; 还有个问题，如果每次打包时需要手动修改 env 环境变量的值，也挺麻烦的。我们可以利用 gulp-replace 在 gulp 打包的时候进行环境自动切换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const watch = require('gulp-watch');const replace = require('gulp-replace');const gulpSequence = require('gulp-sequence');const Alias = require('gulp-wechat-weapp-src-alisa');// js task 不处理 env.js 文件的打包gulp.task('js', function() &#123; return gulp.src(['src/**/*.js', `!src/env/env.js`]) .pipe(Alias(aliasConfig)) .pipe(gulp.dest('dist/'))&#125;)// envCompile task 对 env.js 进行打包gulp.task('envCompile:dev', function () &#123; return gulp.src(['src/env/env.js']) // 把匹配到的环境变量替换成 'dev' .pipe(replace(/['"](.+)['"]/, function(match) &#123; console.log('match', match) return "'dev'" &#125;)) .pipe(gulp.dest('dist/env'))&#125;)gulp.task('envCompile:production', function () &#123; return gulp.src(['src/env/env.js']) // 把匹配到的环境变量替换成 'production' .pipe(replace(/['"](.+)['"]/, function(match) &#123; console.log('match', match) return "'production'" &#125;)) .pipe(gulp.dest('dist/env'))&#125;)// ... 省略一些 taskgulp.task('watch', function() &#123; function w(path, task) &#123; watch(path, function () &#123; gulp.start(task); &#125;) &#125; w('src/**/*', ['wxss']); w('src/**/*.js', ['js']); w('src/**/*.html', ['wxml']); w('src/**/*.png', ['image']); w('src/**/*.json', ['json']);&#125;);gulp.task('dev', function(cb) &#123; gulpSequence('del', 'image', 'wxss', 'js', 'wxml', 'json', 'envCompile:dev', 'watch', cb);&#125;);gulp.task('production', function(cb) &#123; gulpSequence('del', 'image', 'wxss', 'js', 'wxml', 'json', 'envCompile:production', 'watch', cb);&#125;); 这样运行 gulp dev 就是跑的就是 dev 环境下的接口，gulp production 就是 production 环境下的接口。 最后，为了防止上线前没有运行 gulp production，需要在微信开发者工具里增加自定义处理命令，在每次上传前运行 gulp envCompile:production: 123456// project.config.json 文件 "scripts": &#123; "beforeCompile": "", "beforePreview": "", "beforeUpload": "gulp envCompile:production" &#125;, 至此，小程序项目就构建得差不多啦。下次给大家带来的是小程序性能方面的相关话题。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小程序项目构建（一）]]></title>
    <url>%2F2019%2F07%2F19%2FminiProgram-start1%2F</url>
    <content type="text"><![CDATA[当我们在准备开发微信小程序之前，首先要进行框架选型。现在微信小程序框架有好几种，我们该怎样来选择一个适合自己项目的框架呢？ 1. 框架选型下面列出原生框架和一些主流框架之间的对比： 原生 mpvue wepy taro 语法 小程序 vue.js 类vue.js react.js 标签 小程序 html + 小程序 小程序 小程序 组件规范 小程序组件 vue 组件规范 小程序自定义组件 react 组件规范 样式规范 wxss sass, less, stylus sass, less, stylus sass, less, stylus, CSS Modules 多端复用 小程序 H5, 小程序 H5, 小程序 H5, RN, 小程序 数据管理 无 Vuex Redux Redux/Mobx/Dva 自动构建 无 webpack 框架内置 webpack 成本 学习小程序 学习 vue 学习 vue 和 wepy 学习 react 可以看到：原生框架在自动构建、 css 预处理、数据管理和多端复用有一定的欠缺。 但是综合考虑到我们的业务需求和团队成员，还是选择了使用原生框架进行开发： 对多端复用的需求较弱; 团队里熟悉 vue 和小程序语法的同学较多; 时间有限，不想踩太多坑。 其实使用原生框架还有下面几个好处： 小程序特性更新迭代较快，可以尽快使用新特性而不需要考虑三方框架更新的问题； 排查问题、性能调优更方便。 那么，既然选择了原生框架，那么接下来几个明显的短板问题需要解决。 2. 自动构建小程序开发者工具其实已经提供了部分能力: ES7/ES6 转 ES5 样式补全 NPM 包管理 压缩混淆 … 剩下的构建工作涉及文件处理比较多，使用 gulp 开发效率较高，所以我们使用 gulp 来进行工程化处理。 3. css 预处理一般来说使用 less / sass / stylus 都可以。这里使用 less 举例： 123456789gulp.task(&apos;wxss&apos;, function() &#123; return gulp.src([&apos;src/**/*.less&apos;]) .pipe(less()) .pipe(minifyCss()) .pipe(rename(&#123; extname: &quot;.wxss&quot; &#125;)) .pipe(gulp.dest(&apos;dist&apos;))&#125;); 4. 数据管理小程序本身缺少全局状态管理和跨页通讯。如果业务和逻辑没那么复杂，我们可以使用 globalData 或 localStorage 作为数据中转。如果数据管理比较复杂，可以考虑接入 westore 来解决这个痛点。 5. 常用方法的封装5.1 环境变量的控制Env.js 中进行统一管理： 1234567891011121314module.exports = &#123; dev: &#123; api: &apos;https://dev.api.com/&apos; &#125;, test01: &#123; api: &apos;https://test01.api.com/&apos; &#125;, test02: &#123; api: &apos;https://test02.api.com/&apos; &#125;, production: &#123; api: &apos;https://pro.api.com/&apos; &#125;&#125; 在请求时根据当前环境选择相应配置： 1234let Env_config = require(&apos;./env/index&apos;)let env = &apos;dev&apos;console.log(Env_config[env]) 5.2 request 封装wx.request 是我们向后端请求接口的 API。在项目中，我们要对其进行封装，在 header 或 data 中加入公共参数，还需要对错误进行统一拦截，以及根据环境请求不同的接口。 123456789101112131415161718192021222324252627282930313233343536373839getRequest: function(data) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: Env_config[env].api + data.url, method: data.method || "GET", header: Object.assign(&#123; "Content-Type": "application/json", "Server-Token": "xxxxxx" &#125;, data.header), data: data.data, success: (res) =&gt; &#123; if (res &amp;&amp; res.statusCode === 200) &#123; resolve(res) &#125; else if (res.statusCode === 401) &#123; wx.showToast(&#123; title: '登录失效，请重新登录', icon: 'none', success: function () &#123; // 登录失效的回调 &#125; &#125;) &#125; else &#123; wx.showToast(&#123; title: res.msg || '服务异常，请稍后重试', icon: 'none' &#125;) reject(res) &#125; &#125;, fail: (err) =&gt; &#123; wx.showToast(&#123; title: err.msg || '服务异常，请稍后重试', icon: 'none' &#125;) reject(err) &#125; &#125;) &#125;)&#125; 这样我们就可以对封装的接口进行 promise 化的处理： 12345678910 app.getRequest(&#123; url: "api/test", data: &#123; span: 30 &#125;&#125;).then(res =&gt; &#123; // 成功回调&#125;).catch(err =&gt; &#123; // 失败回调&#125;) 我们也可以对其他的微信 API 做 Promise 化的处理封装，避免在复杂的业务逻辑中陷入回调地狱。 如果想支持 async/await 的语法，可以尝试引入 facebook 的 regeneratorRuntime。 wx-promise-pro 这个将小程序异步 API Promsie 化的工具库，也不失为一种不错的选择。 5.3 多环境切换因为小程序只会存在一个预览版本，所以测试同学需要在其他环境测试时，都需要找到开发同学手动更改环境并重新发布体验版，非常之麻烦。所以打算利用微信摇一摇来实现环境的切换。由于这周时间比较紧张，所以下次再贴代码实现吧！ 其他的相关问题想到再补充，大家也可以提一提自己的看法。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序底层架构]]></title>
    <url>%2F2019%2F07%2F11%2FminiProgram%2F</url>
    <content type="text"><![CDATA[1. 与h5页面的区别从技术的发展角度来看，微信小程序是从微信中的 webView 和 JS-SDK 进化到了今天的形态。那么，小程序和普通的h5页面到底有什么区别呢？ 运行环境：小程序基于浏览器内核重构的内置解析器，而 h5 的宿主环境是浏览器。所以小程序中没有 DOM 和 BOM 的相关 API，jQuery和一些 NPM 包都不能在小程序中使用； 系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等； 渲染机制：小程序的逻辑层和渲染层是分开的，而 h5 页面 UI 渲染跟 JavaScript 的脚本执行都在一个单线程中，互斥。所以 h5 页面中长时间的脚本运行可能会导致页面失去响应。 其实，小程序开发过程中我们面对的是 iOS 和 Android 微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的： 运行环境 逻辑层 渲染层 iOS JavaScriptCore WKWebView Android X5 JSCore X5浏览器 小程序开发者工具 NWJS Chrome WebView 所以微信小程序介于 web 端和原生 App 之间，能够丰富调用功能接口，同时又跨平台。 2. 小程序架构2.1 双线程模型小程序的渲染层和逻辑层分别由2个线程管理： 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView线程。 逻辑层：采用 JsCore 线程运行JS脚本。 视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。 （页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面） 双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。 2.2 组件系统我们知道小程序是有自己的组件的，这些基本组件就是基于 Exparser 框架。 Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖浏览器的原生支持，而且可在 纯 JS 环境中运行。 小程序中，所有节点树相关的操作都依赖于 Exparser，包括 WXML 到页面最终节点树的构建、CreateSelectorQuery 调用和自定义组件特性等。 现在微信小程序也支持自定义组件了，用法和组件间通信类似于 Vue。 2.3 原生组件在内置组件中，有一些组件并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染。比如说 Map 组件。它渲染的层级比在 WebView 层渲染的普通组件要高。 引入原生组件的优点是： 扩展 Web 的能力 体验更好，减轻 WebView 的渲染工作 绕过 setData、数据通信和重渲染流程，性能更好 2.4 运行机制2.4.1 启动 热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动； 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 2.4.2 销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 2.5 更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。 小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 所以如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能： 1234567891011121314checkNewVersion() &#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; console.log('hasUpdate', res.hasUpdate); // 请求完新版本信息的回调 if (res.hasUpdate) &#123; updateManager.onUpdateReady(() =&gt; &#123; this.setData(&#123; hasNewVersion: true &#125;); &#125;); &#125; &#125;); &#125; 微信小程序的基础底层架构大概就这么多，有机会再看看源码思考解析吧。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图坐标系知多少]]></title>
    <url>%2F2019%2F07%2F04%2Fcoordinate%2F</url>
    <content type="text"><![CDATA[今天收到产品反馈，有客户发现在微信小程序中使用百度地图导航，导航位置并不准确。这就奇怪了，相同的经纬度坐标在不同地图上为什么显示会有偏差，到底有哪些坐标体系呢？ 1. 常见坐标系1.1 GPS 坐标系（wgs84）wgs84: WorldGeodetic System 1984 ，全世界最流行的基准标准系统，是由美国国防部制图局建立。通常通过底层接口得到的定位信息都是 wgs84 坐标系。 1.2 火星坐标系（GCJ02）GCJ-02 是国内最广泛使用的坐标体系，是由中国国家测绘局制订的地理信息系统的坐标系统。 它是一种对经纬度数据的加密算法，即加入随机的偏差，就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。转换完成后，地图上的点会发生几十到几百米的偏移。加密后的坐标也常被人称为火星坐标系统（才不是我们生活在火星上呢）。 谷歌中国，腾讯地图，高德地图都在用这个坐标体系。 那么问题来了，地图是偏移的，为什么使用手机地图的时候没感觉到呢？ 因为除了对手机地图加偏外，用户的定位也被加偏处理后再显示在地图上。相关坐标都被同一算法给加偏后，两者完全匹配， GPS 也就可以正常工作，所谓的负负得正 😆 。 所以在国内出版的各种地图系统、导航设备等，都需要加入国家保密插件。 1.3 其他坐标体系一般都是由 GCJ-02 再次经过偏移算法得到。比如说百度地图（BD-09坐标系）、搜狗地图。 2. 坐标转换既然有好几种不同的坐标系，自然一个坐标不能同时应用于所有情形，使用前要进行适当转换。常见的有下面几种方式。 2.1 算法转换github 上有很多语言提供的转换库，这里列举了一个 Js 库。可以在 NodeJs 或 浏览器中使用：coordtransform 坐标转换https://github.com/wandergis/coordtransform 优点：直接使用，方便快捷缺点：看了相关的 issue 发现，在某些坐标系转换时，还是会有一定的误差。 2.2 Web API 转换通过各类地图的 Web API 对坐标进行相互转换。 高德坐标转换 百度坐标转换 GPS坐标转换 优点：因为是官方提供的坐标转换，转换的准确度应该较高缺点：得在官方申请相应账号和权限，请求时要传入 key, id 等加密信息。而且得需要额外的网络请求。 2.3 SDK API 转换通过嵌入相应的 sdk 后进行转换： 高德sdk 百度sdk 所以综合考虑后，小程序项目的解决方案就是后端通过相关算法对坐标进行了统一转换。大家可以在遇到类似问题时选择适合自己的解决方案。]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 数组乱序]]></title>
    <url>%2F2019%2F07%2F01%2Fshuffle%2F</url>
    <content type="text"><![CDATA[1. 定义数组乱序就是把数组存储值的顺序都打乱。通常我们在做抽奖系统或者发牌等游戏时，会遇到数组乱序的问题。举个例子：将 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 乱序。 2. sort 方法通常我们最快想到的方法是利用 sort。 1234567function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;console.log(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))// =&gt; [3, 5, 9, 10, 7, 6, 4, 8, 1, 2] 乍一看没问题，但是运行次数多了我们就会发现，末尾的数字为大数的概率较大，开始的数字为小数的概率较大。 我们可以验证下，10000 次随机测试，10 个位置，每个位置的平均值应该是一样的，即 (1+10)*10/2/10 = 5.5: 123456789101112131415161718192021const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [48544, 48860, 55333, 56927, 56797, 53396, 53790, 56762, 58967, 60624]// =&gt; [4.8544, 4.886, 5.5333, 5.6927, 5.6797, 5.3396, 5.379, 5.6762, 5.8967, 6.0624] 可以看到，每个位置平均值有比较明显的误差。那么这是什么原因呢？ 原来，在Chrome v8引擎源码中，处理sort方法时，使用了插入排序和快速排序两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快速排序和插入排序的混合排序。 所以用 sort 方法乱序不准确的原因就在于：理想的方案是数组中每两个元素都要进行比较，这个比较有50%的交换位置概率。而在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。 3. 洗牌算法可以利用洗牌算法来进行彻底的乱序。洗牌算法的思路是： 先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置；然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换；以此类推，打乱整个数组的顺序。 1234567function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125; 这时再测试下： 12345678910111213141516171819202122232425const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [55070, 54854, 54588, 55169, 55458, 54670, 55311, 54944, 55030, 54906]// =&gt; [5.507, 5.4854, 5.4588, 5.5169, 5.5458, 5.467, 5.5311, 5.4944, 5.503, 5.4906] 我们可以看到，已经是真正的乱序啦。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js 函数防抖和节流]]></title>
    <url>%2F2019%2F06%2F25%2Fthrottle%2F</url>
    <content type="text"><![CDATA[我们前端在实际开发过程中，经常会遇到如下问题： 页面的 scroll 事件 input 输入检测事件 高频点击提交 如果不做任何处理的话，页面可能会卡顿，性能较低。这时候就需要函数防抖和节流来出马啦。 1. 函数防抖1.1 定义在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 例子：电梯是在等人进入10秒后自动关闭。如果电梯进人后10s内再次有人进入，则又得等10秒钟电梯才会自动关闭。如果中间一直进人，就一直不会关闭。 1.2 代码实现思路：用定时器执行函数，判断如果存在定时器任务，则清空定时器，重新开启一个新的定时器 简易代码： 12345678910// fn 是需要执行的函数, interval 是等待时间间隔function debounce(fn, interval = 300) &#123; let timeout = null return function() &#123; clearTimeout(timeout) timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 但是这一版防抖有个缺点，就是第一次不会执行，得等到 interval 后才会执行，如果需要首次执行，可修改代码如下： 123456789101112131415// immediate 为 true 代表需要立即执行 fn, 为 false 代表不需要function debounce(fn, interval = 1000, immediate) &#123; let timeout = null let first = true return function() &#123; clearTimeout(timeout) if (immediate &amp;&amp; first) &#123; fn.apply(this, arguments) first = false &#125; timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 1.3 使用123document.querySelector('body').addEventListener('mousemove', debounce((e) =&gt; &#123; console.log(e.clientY)&#125;, 300, true)) 如图，对 mousemove事件防抖： 2. 函数节流2.1 定义规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 例子: 在页面滚动时，会不断地触发 scroll 事件，实际上我们不需要这么频繁地去执行函数，这是就可以设置一个间隔，比如说 300ms，在 300ms 这个时间内，scroll 内的函数只能执行一次。 2.2 代码实现思路 1：用时间轴来判断，如果事件触发时间与上一次函数执行时间之差大于规定时间，则执行一次，反之不执行 代码 1： 1234567891011// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let pre = 0 return function() &#123; const now = Date.now() if (now - pre &gt; interval) &#123; fn.apply(this, arguments) pre = now &#125; &#125;&#125; 这个函数特点是：会立刻执行，停止触发后就不会执行。 思路 2：用定时器，在定时器未执行的时间内，再次触发的函数将不再执行。 代码 2： 1234567891011121314// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let canRun = true return function() &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; &#125; 这个函数特点是：等待 interval 时间间隔后才执行，停止触发后会再执行一次。 把思路 1 和思路 2 结合起来，用变量来控制第一次是否执行及停止触发后是否再执行一次： 123456789101112131415161718192021222324252627282930313233// options 作为第三个参数,// options.leading 为 true 时表示第一次就执行，// options.trailing 为 true 是表示停止触发时再执行一次function throttle(fn, interval = 1000, options = &#123;&#125;) &#123; let pre = 0 let canRun = true let first = options.leading || false return function() &#123; if (first) &#123; fn.apply(this, arguments) first = false &#125; if (options.trailing) &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; else &#123; const now = Date.now() if (now - pre &gt; interval) &#123; if (pre) &#123; fn.apply(this, arguments) &#125; pre = now &#125; &#125; &#125;&#125; 2.3 使用123456document.querySelector('body').addEventListener('mousemove', throttle((e) =&gt; &#123; console.log(e.clientY)&#125;, 1000, &#123; leading: true, trailing: true&#125;)) 如图，对 mousemove事件节流：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（二）]]></title>
    <url>%2F2019%2F06%2F20%2FregExp2%2F</url>
    <content type="text"><![CDATA[1. Js 中关于正则的 API1.1 String 中的方法 search search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 1234var str="Mr. Blue has a blue house";console.log(str.search(/blue/i));// =&gt; 4// 注意 /i 表示对大小写忽略，所以找到了 Blue 的位置，即为 4 split split() 方法用于把一个字符串分割成字符串数组，接受的参数为字符串或正则表达式。 1234var str="How are you doing today?";var n=str.split(/\s/);console.log(n);// =&gt; ["How", "are", "you", "doing", "today?"] match match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，接受的参数为 regexp。 注意：match 返回结果的格式，与正则对象是否有修饰符 g 有关。 没有 g，返回的是标准匹配格式，即数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有 g，返回的是所有匹配的内容。 当没有匹配时，不管有无 g，都返回 null。 1234567var string = "2019/06/18";var regex1 = /\b(\d+)\b/;var regex2 = /\b(\d+)\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; ["2019", "2019", index: 0, input: "2019/06/18", groups: undefined]// =&gt; ["2019", "06", "18"] replace replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。语法为 string.replace(regexp|substr, newSubStr|function)。 replace 有两种使用形式，因为它的第二个参数，可以是字符串，也可以是函数。 当第二个参数是字符串时，我们可以用 $1,$2,...,$99 来匹配第 1-99 个分组里捕获的文本 123var result = "2,3,5".replace(/(\d+),(\d+),(\d+)/, "$3=$1+$2");console.log(result);// =&gt; "5=2+3" - 当第二个参数是函数时，在这种情况下，当匹配执行后，该函数就会执行。函数的返回值作为替换字符串。 注意：如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。下面是该函数的参数。 |参数|含义| |:---:|:---:| |`match`|匹配的子串| |`$1, $2, ...`|匹配的分组，对应于上例的`$1，$2，...`| |`index`|匹配到的子字符串在原字符串中的下标| |`input`| 被匹配的原字符串| 如下例，匹配一个四位数字，把中间两位数字变成 `**` 123456789var result = "1234 2345 3456".replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]); return `$&#123;$1&#125;**$&#123;$2&#125;`&#125;);console.log(result);// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"]// =&gt; 1**4 2**5 3**6 1.2 RegExp 中对象方法 exec exec() 方法用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.exec(str);console.log(result);// =&gt; ["Hello", index: 0, input: "Hello world!", groups: undefined] test test() 方法用于检测一个字符串是否匹配某个模式。如果字符串中有匹配的值返回 true ，否则返回 false。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.test(str);console.log(result);// =&gt; true 2. 常用正则表达式2.1 数字的千位符表示情形：把一串整数转换成千位分隔形式，例如 12345678，转换成 12,345,678 。 思路：从个位往左数起，每三位前插入一个千位分隔符，即可以想象成我们要把每三位数字前面的空 &quot;&quot;（即位置）匹配出来，并替换成千位分隔符。 做法：首先因为需要从右往左匹配，$ 是必须要有的。三位数字用 \d{3}，不确定多少组，用 (\d{3})+，所以目前为 /(\d{3})+$/g。由于替换的是位置，所以需要用到位置锚 (?=p)，即 /(?=(\d{3})+$)/g: 123var result = "12345678".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 12,345,678 但如果是 9 位数字的话， 123var result = "123456789".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; ,123,456,789 所以我们可以在匹配的位置前加一个非单词边界 \B,即 /(?=(\B\d{3})+$)/g: 123var result = "123456789".replace(/(?=(\B\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 123,456,789 2.2 模拟 trim 方法情形：去掉字符串的开头和结尾的空白符 思路：还是匹配位置，替换成 &#39;&#39; 做法： 12345function trim(str) &#123; return str.replace(/^\s+|\s+$/g, '');&#125;console.log(trim(" test ") );// =&gt; test 2.3 单词首字母大写情形：把 i&#39;m a curious babe 转化成 I&#39;m A Curious Babe 思路: 找到首字母并替换之 做法： 1234567function upperTitle(str) &#123; return str.replace(/(^|\s)\w/g, function(match) &#123; return match.toUpperCase(); &#125;)&#125;console.log(upperTitle("i'm a curious babe"));// =&gt; I'm A Curious Babe 驼峰化的思路是一样的： 12345678910function camelize (str) &#123; return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123; console.log(match, c); return c ? c.toUpperCase() : ''; &#125;);&#125;console.log(camelize('-moz-transform'));// =&gt; -m m// =&gt; -t t// =&gt; MozTransform 2.4 验证身份证情形: 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x 做法：(^\d{15}$)|(^\d{17}(\d|X|x)$) 1234var reg = /(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/;var id = '25271618827172817X';console.log(reg.test(id));// =&gt; true 2.5 验证手机号情形：以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码 做法：^1[3,4,5,7,8,9]\d{9}$ 2.6 验证邮箱情形：以大写字母 [A-Z]、小写字母 [a-z]、数字[0-9]、下滑线_、减号-及点号.开头，并需要重复一次至多次[+]; 中间必须包括 @ 符号;@ 之后需要连接大写字母 [A-Z]、小写字母 [a-z]、数字 [0-9]、下滑线 _、减号 -及点号.，并需要重复一次至多次[+];结尾必须是点号 . 连接2至4位的大小写字母 [A-Za-z]{2,4}。 做法：/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/ 123var reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/;var email = 'test-babe@163.com';console.log(reg.test(email)); 2.7 验证密码情形：密码长度 6-12 位，由数字、小写字母和大写字母组成，但必须至少包括 2 种字符。 思路1：密码长度6-12位，由 [\da-zA-Z]组成，可以写成 /^[\dA-Za-z]{6,12}$/；至少包含数字，可以写成 /(?=.*\d)/ 那么，至少包含两种字符就变成了 - 同时包含数字和小写字母 - 同时包含数字和大写字母 - 同时包含小写字母和大写字母 - 同时包含数字、小写字母和大写字母（这种情况被前三种情况包含） 做法1：所以最终写法为：/((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]{6,12}$/ 12345678var regex = /((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 思路2：至少包含两种字符的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。不能全部是数字的正则是：(?!^\d{6, 12}$)^[\da-zA-Z]{6,12}$ 做法2：所以最终写法为：/(?!^\d{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[\dA-Za-z]{6,12}$/ 12345678var regex = /(?!^\d&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程 MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（一）]]></title>
    <url>%2F2019%2F06%2F18%2FregExp1%2F</url>
    <content type="text"><![CDATA[1. 定义正则表达式通俗的讲就是按照某种规则去匹配符合条件的字符串。 在前端开发中经常能够遇到它，比如说表单验证，字符处理等。虽然功能及其强大，在几乎所有语言中都可以使用，但是其繁杂的语法使其成了许多前端同学包括我的一个痛点。 所以今天做一个总结，理解最常用的正则语法。这样下次遇到正则表达式问题时就可以自己独立解决了。 先放上核心总结： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 2. 工具正则表达式可视化工具https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24 我们可以利用这个工具辅助理解正则表达式 3. 字符匹配3.1 字符组最简单的正则表达式可以由数字或字母组成。比如说如果想在 monky 这个单词里找到 o 这个字符，就直接用 /o/ 这个正则就可以了。 123var regex = /o/;console.log( regex.test("monkey") );// =&gt; true 在正则表达式里，范围表示法使用中括号 []。例 [123] 表示匹配一个字符，它可以是 1、2、3 之一。如果需要匹配所有的数字，可以使用 [0123456789]，还可以简写成[0-9]。同理，匹配任意小写字母可以写成 [a-z]。 如果想匹配不以数字开头的字符呢，可以用排除字符组 [^]。例如[^0-9] 表示是一个除数字之外的任意一个字符。 下面是一些常用的字符组： 字符组 含义 记忆方法 \d 匹配一个数字字符，等价于 [0-9] digit \D 匹配一个非数字字符，等价于 [^0-9] \w 匹配字母、数字、下划线，等价于 [A-Za-z0-9_] word \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_] \s 匹配任何空白字符，包括空格、制表符、换页符，回车符等等，等价于 [ \f\n\r\t\v] (注意正则前面有个空格) space \S 匹配任何非空白字符，等价于 [^ \f\n\r\t\v] . 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外，等价于 [^\n\r\u2028\u2029] 注意：如果你想查找元字符本身的话，需要使用 \ 来转义，比如说查找. 和 \，就得使用 \. 和 \\。 3.2 重复比如说 \d{3} 表示 数字 必须重复三次。 下面是一些常用的重复限定符： 限定符 含义 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 3.3 贪婪匹配与惰性匹配正则表达式在匹配时，默认行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。 1234var regex = /a.*b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aabab&quot;] 以这个表达式为例：它会匹配整个字符串 aabab 。这被称为贪婪匹配。 有时我们需要惰性匹配，也就是匹配尽可能少的字符。这时候前面给出的重复限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。 1234var regex = /a.*?b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aab&quot;, &quot;ab&quot;] 下面是一些常用的惰性重复限定符： 限定符 含义 *? 重复零次或更多次，但尽可能少重复 +? 重复一次或更多次，但尽可能少重复 ?? 重复零次或一次，但尽可能少重复 {n,}? 重复n次或更多次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 3.4 分支正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 | 把不同的规则分隔开。比如说：(apple|banana|watermelon) 表示匹配 apple 或 banana 或watermelon`。 1234var regex = /apple|banana|watermelon/g;var string = &quot;would you like apple or banana?&quot;;console.log(string.match(regex));// =&gt; [&quot;apple&quot;, &quot;banana&quot;] 4. 位置匹配如图，位置(锚)是相邻字符之间的位置。 常见的位置锚有： 位置锚 含义 ^ 匹配开头，在多行匹配中匹配行开头 $ 匹配结尾，在多行匹配中匹配行结尾 \b boundary，单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置 \B 非单词边界，与 \b 相反，是 \w 与 \w、 \W 与 \W、\W 与 ^，\W 与 $ 之间的位置 (?=p) p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p（匹配的是位置） (?!p) p 是一个子模式，即 非p字符 前面的位置，或者说，该位置后面的字符不能有 p（匹配的是位置） 其可视化形式见下图： 下面两个例子，第一个是匹配以 ing 结尾的单词的前面部分(除了ing以外的部分)，第二个是匹配不以 s 和 d 开头的单词。 123456789var regex = /\b\w+(?=ing\b)/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["sing", "danc"]var regex = /\b(?!(s|d))\w+\b/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["I", "m", "while", "you", "re"] 两个例子的可视化形式见下图: 5. 分组正则中用小括号来指定分组(也叫做子表达式)。比如说 (abc)+ ，就是一个分组，小括号使 abc 成了一个整体。 5.1 分组引用对字符串使用带 () 的正则操作后，可以通过 $1, $2, ... 或者全局的 RegExp.$1, RegExp.$2, ... 来对分组数据进行引用。 12345var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date = "2019-06-18";var result = date.replace(regex, "$2/$3/$1");console.log(result);// =&gt; "06/18/2019" 等价于： 1234567var regex2 = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date2 = "2019-06-19";var result2 = date2.replace(regex2, function () &#123; return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;&#125;);console.log(result2);// =&gt; "06/19/2019" 5.2 反向引用反向引用指的是模式的后面部分引用前面已经匹配到的子字符串。语法是 \1,\2,.... ,其中 \1 表示引用的第一个子表达式，\2 表示引用的第二个子表达式，以此类推。而 \0 则表示整个表达式。 12345678var regex = /(\d&#123;3&#125;)([a-z]&#123;3&#125;)\1\2/;var string = '123abc123abc';console.log(regex.test(string));console.log(RegExp.$1);console.log(RegExp.$2);// =&gt; true// =&gt; 123// =&gt; abc 上例中，\1 表示第一个分组内容，即 123，\2 表示第二个分组内容，即 abc。 5.3 非捕获括号普通的括号都会捕获匹配数据，以便后续引用。如果我们不需要引用，为了节约内存，可以使用非捕获括号 (?:regex) 例如 (?:abc)，下图已经没有了 Group #1 的标识 6. 符号优先级当各种运算符号混杂在一起时，确定其优先级成为了一件至关重要的事。下表是常用操作符的运算优先级，优先级从高到底： 操作符描述 操作符 优先级 转义符 \ 1 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 2 量词限定符 {m}、{m,n}、{m,}、?、*、+ 3 位置和序列 ^、$、\元字符、一般字符 4 管道符(竖杠) ` ` 例 /ab?(c|de*)+|fg/，其可视化形式为： 到这里为止，正则的基本语法就讲完了。还记得开头的核心总结吗： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 是不是对这句话有了较为深入的理解。接下来的文章会介绍 Js 里一些正则的 API，并结合实例来说明一些常用正则的使用。 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[1. 定义Markdown 是一种轻量级标记语言，让作者专注于写作而不用关注样式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面（且Markdown是兼容HTML语法的）。所以用Markdown写文章是最适合不过的啦。 2. 基本语法Markdown 的语法全由一些符号所组成，其语法主要分为如下几大部分： 标题，段落，分隔线，字体，引用，图片，超链接，列表，表格，代码片段。 2.1 标题在文本前面加上 # 即可创建一级标题。同理，创建二级标题、三级标题等只需要增加 # 个数即可，Markdown 共支持六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 段落使用Markdown分段非常简单，前后至少保留一个空行即可。 123第一段文字...第二段文字... 效果： 第一段文字… 第二段文字… 2.3 分隔线三个以上的短线 即可作出分割线。 1--- 效果： 2.4 字体 倾斜：左右分别用一个*号包起来 加粗：左右分别用两个*号包起来 倾斜加粗：左右分别用三个*号包起来 删除线：左右分别用两个~~号包起来 1234*倾斜***加粗*****倾斜加粗***~~加删除线~~ 效果： 倾斜加粗倾斜加粗加删除线 2.5 引用在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt;, 三个 &gt;&gt;&gt;甚至更多 123&gt; 这是引用的内容&gt;&gt; 这是引用的内容&gt;&gt;&gt;&gt;&gt; 这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 2.6 图片1![图片alt](图片地址 &quot;图片title&quot;) 图片alt就是显示在图片显示不出来时替代的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 1![妙蛙种子](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=580eddc172d98d1076d40b371904df33/8326cffc1e178a82cfd2349df803738da977e825.jpg &quot;妙蛙种子&quot;) 效果： 注意：到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 2.7 超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 1[知乎](https://www.zhihu.com) 效果： 知乎 注意：Markdown也支持传统的HTML标签，你也可以直接写成&lt;a href=&quot;https://www.zhihu.com&quot;&gt;知乎&lt;/a&gt; 2.8 列表 无序列表无序列表用 - + * 任一开头都可以。注意：- + * 跟内容之间都要有一个空格 123- 列表内容+ 列表内容* 列表内容 效果： 列表内容 列表内容 列表内容 有序列表数字加点即可。注意：序号跟内容之间要有空格，且列表可以嵌套 1231.列表内容2.列表内容3.列表内容 效果： 1.列表内容 2.列表内容 3.列表内容2.9 表格123456789|表头|表头|表头||---|:---:|---:||内容短|内容|内容长一点||内容|内容|内容|第二行分割表头和内容。文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果： 表头 表头 表头 内容短 内容 内容长一点 内容 内容 内容 2.10 代码 单行代码：代码之间分别用一个反引号包起来 多行代码：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1`代码内容` 多行代码 多行代码 多行代码 12345```效果：`代码内容` 多行代码 多行代码 多行代码``` 3. 使用以下是常用的 markdown 工具和支持 markdown 语法的在线平台 软件 mweb 马克飞象 Mou 平台 github 简书 Stack Overflow 在线编辑器 Cmd Markdown 编辑阅读器]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
