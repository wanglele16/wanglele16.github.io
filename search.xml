<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序底层架构]]></title>
    <url>%2F2019%2F07%2F11%2FminiProgram%2F</url>
    <content type="text"><![CDATA[1. 与h5页面的区别从技术的发展角度来看，微信小程序是从微信中的 webView 和 JS-SDK 进化到了今天的形态。那么，小程序和普通的h5页面到底有什么区别呢？ 运行环境：小程序基于浏览器内核重构的内置解析器，而 h5 的宿主环境是浏览器。所以小程序中没有 DOM 和 BOM 的相关 API，jQuery和一些 NPM 包都不能在小程序中使用； 系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等； 渲染机制：小程序的逻辑层和渲染层是分开的，而 h5 页面 UI 渲染跟 JavaScript 的脚本执行都在一个单线程中，互斥。所以 h5 页面中长时间的脚本运行可能会导致页面失去响应。 其实，小程序开发过程中我们面对的是 iOS 和 Android 微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的： 运行环境 逻辑层 渲染层 iOS JavaScriptCore WKWebView Android X5 JSCore X5浏览器 小程序开发者工具 NWJS Chrome WebView 所以微信小程序介于 web 端和原生 App 之间，能够丰富调用功能接口，同时又跨平台。 2. 小程序架构2.1 双线程模型小程序的渲染层和逻辑层分别由2个线程管理： 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView线程。 逻辑层：采用 JsCore 线程运行JS脚本。 视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。 （页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面） 双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。 2.2 组件系统我们知道小程序是有自己的组件的，这些基本组件就是基于 Exparser 框架。 Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖浏览器的原生支持，而且可在 纯 JS 环境中运行。 小程序中，所有节点树相关的操作都依赖于 Exparser，包括 WXML 到页面最终节点树的构建、CreateSelectorQuery 调用和自定义组件特性等。 现在微信小程序也支持自定义组件了，用法和组件间通信类似于 Vue。 2.3 原生组件在内置组件中，有一些组件并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染。比如说 Map 组件。它渲染的层级比在 WebView 层渲染的普通组件要高。 引入原生组件的优点是： 扩展 Web 的能力 体验更好，减轻 WebView 的渲染工作 绕过 setData、数据通信和重渲染流程，性能更好 2.4 运行机制2.4.1 启动 热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动； 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 2.4.2 销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 2.5 更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。 小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 所以如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能： 1234567891011121314checkNewVersion() &#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; console.log(&apos;hasUpdate&apos;, res.hasUpdate); // 请求完新版本信息的回调 if (res.hasUpdate) &#123; updateManager.onUpdateReady(() =&gt; &#123; this.setData(&#123; hasNewVersion: true &#125;); &#125;); &#125; &#125;); &#125; 微信小程序的基础底层架构大概就这么多，有机会再看看源码思考解析吧。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图坐标系知多少]]></title>
    <url>%2F2019%2F07%2F04%2Fcoordinate%2F</url>
    <content type="text"><![CDATA[今天收到产品反馈，有客户发现在微信小程序中使用百度地图导航，导航位置并不准确。这就奇怪了，相同的经纬度坐标在不同地图上为什么显示会有偏差，到底有哪些坐标体系呢？ 1. 常见坐标系1.1 GPS 坐标系（wgs84）wgs84: WorldGeodetic System 1984 ，全世界最流行的基准标准系统，是由美国国防部制图局建立。通常通过底层接口得到的定位信息都是 wgs84 坐标系。 1.2 火星坐标系（GCJ02）GCJ-02 是国内最广泛使用的坐标体系，是由中国国家测绘局制订的地理信息系统的坐标系统。 它是一种对经纬度数据的加密算法，即加入随机的偏差，就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。转换完成后，地图上的点会发生几十到几百米的偏移。加密后的坐标也常被人称为火星坐标系统（才不是我们生活在火星上呢）。 谷歌中国，腾讯地图，高德地图都在用这个坐标体系。 那么问题来了，地图是偏移的，为什么使用手机地图的时候没感觉到呢？ 因为除了对手机地图加偏外，用户的定位也被加偏处理后再显示在地图上。相关坐标都被同一算法给加偏后，两者完全匹配， GPS 也就可以正常工作，所谓的负负得正 😆 。 所以在国内出版的各种地图系统、导航设备等，都需要加入国家保密插件。 1.3 其他坐标体系一般都是由 GCJ-02 再次经过偏移算法得到。比如说百度地图（BD-09坐标系）、搜狗地图。 2. 坐标转换既然有好几种不同的坐标系，自然一个坐标不能同时应用于所有情形，使用前要进行适当转换。常见的有下面几种方式。 2.1 算法转换github 上有很多语言提供的转换库，这里列举了一个 Js 库。可以在 NodeJs 或 浏览器中使用：coordtransform 坐标转换https://github.com/wandergis/coordtransform 优点：直接使用，方便快捷缺点：看了相关的 issue 发现，在某些坐标系转换时，还是会有一定的误差。 2.2 Web API 转换通过各类地图的 Web API 对坐标进行相互转换。 高德坐标转换 百度坐标转换 GPS坐标转换 优点：因为是官方提供的坐标转换，转换的准确度应该较高缺点：得在官方申请相应账号和权限，请求时要传入 key, id 等加密信息。而且得需要额外的网络请求。 2.3 SDK API 转换通过嵌入相应的 sdk 后进行转换： 高德sdk 百度sdk 所以综合考虑后，小程序项目的解决方案就是后端通过相关算法对坐标进行了统一转换。大家可以在遇到类似问题时选择适合自己的解决方案。]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 数组乱序]]></title>
    <url>%2F2019%2F07%2F01%2Fshuffle%2F</url>
    <content type="text"><![CDATA[1. 定义数组乱序就是把数组存储值的顺序都打乱。通常我们在做抽奖系统或者发牌等游戏时，会遇到数组乱序的问题。举个例子：将 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 乱序。 2. sort 方法通常我们最快想到的方法是利用 sort。 1234567function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;console.log(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))// =&gt; [3, 5, 9, 10, 7, 6, 4, 8, 1, 2] 乍一看没问题，但是运行次数多了我们就会发现，末尾的数字为大数的概率较大，开始的数字为小数的概率较大。 我们可以验证下，10000 次随机测试，10 个位置，每个位置的平均值应该是一样的，即 (1+10)*10/2/10 = 5.5: 123456789101112131415161718192021const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [48544, 48860, 55333, 56927, 56797, 53396, 53790, 56762, 58967, 60624]// =&gt; [4.8544, 4.886, 5.5333, 5.6927, 5.6797, 5.3396, 5.379, 5.6762, 5.8967, 6.0624] 可以看到，每个位置平均值有比较明显的误差。那么这是什么原因呢？ 原来，在Chrome v8引擎源码中，处理sort方法时，使用了插入排序和快速排序两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快速排序和插入排序的混合排序。 所以用 sort 方法乱序不准确的原因就在于：理想的方案是数组中每两个元素都要进行比较，这个比较有50%的交换位置概率。而在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。 3. 洗牌算法可以利用洗牌算法来进行彻底的乱序。洗牌算法的思路是： 先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置；然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换；以此类推，打乱整个数组的顺序。 1234567function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125; 这时再测试下： 12345678910111213141516171819202122232425const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [55070, 54854, 54588, 55169, 55458, 54670, 55311, 54944, 55030, 54906]// =&gt; [5.507, 5.4854, 5.4588, 5.5169, 5.5458, 5.467, 5.5311, 5.4944, 5.503, 5.4906] 我们可以看到，已经是真正的乱序啦。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js 函数防抖和节流]]></title>
    <url>%2F2019%2F06%2F25%2Fthrottle%2F</url>
    <content type="text"><![CDATA[我们前端在实际开发过程中，经常会遇到如下问题： 页面的 scroll 事件 input 输入检测事件 高频点击提交 如果不做任何处理的话，页面可能会卡顿，性能较低。这时候就需要函数防抖和节流来出马啦。 1. 函数防抖1.1 定义在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 例子：电梯是在等人进入10秒后自动关闭。如果电梯进人后10s内再次有人进入，则又得等10秒钟电梯才会自动关闭。如果中间一直进人，就一直不会关闭。 1.2 代码实现思路：用定时器执行函数，判断如果存在定时器任务，则清空定时器，重新开启一个新的定时器 简易代码： 12345678910// fn 是需要执行的函数, interval 是等待时间间隔function debounce(fn, interval = 300) &#123; let timeout = null return function() &#123; clearTimeout(timeout) timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 但是这一版防抖有个缺点，就是第一次不会执行，得等到 interval 后才会执行，如果需要首次执行，可修改代码如下： 123456789101112131415// immediate 为 true 代表需要立即执行 fn, 为 false 代表不需要function debounce(fn, interval = 1000, immediate) &#123; let timeout = null let first = true return function() &#123; clearTimeout(timeout) if (immediate &amp;&amp; first) &#123; fn.apply(this, arguments) first = false &#125; timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 1.3 使用123document.querySelector('body').addEventListener('mousemove', debounce((e) =&gt; &#123; console.log(e.clientY)&#125;, 300, true)) 如图，对 mousemove事件防抖： 2. 函数节流2.1 定义规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 例子: 在页面滚动时，会不断地触发 scroll 事件，实际上我们不需要这么频繁地去执行函数，这是就可以设置一个间隔，比如说 300ms，在 300ms 这个时间内，scroll 内的函数只能执行一次。 2.2 代码实现思路 1：用时间轴来判断，如果事件触发时间与上一次函数执行时间之差大于规定时间，则执行一次，反之不执行 代码 1： 1234567891011// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let pre = 0 return function() &#123; const now = Date.now() if (now - pre &gt; interval) &#123; fn.apply(this, arguments) pre = now &#125; &#125;&#125; 这个函数特点是：会立刻执行，停止触发后就不会执行。 思路 2：用定时器，在定时器未执行的时间内，再次触发的函数将不再执行。 代码 2： 1234567891011121314// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let canRun = true return function() &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; &#125; 这个函数特点是：等待 interval 时间间隔后才执行，停止触发后会再执行一次。 把思路 1 和思路 2 结合起来，用变量来控制第一次是否执行及停止触发后是否再执行一次： 123456789101112131415161718192021222324252627282930313233// options 作为第三个参数,// options.leading 为 true 时表示第一次就执行，// options.trailing 为 true 是表示停止触发时再执行一次function throttle(fn, interval = 1000, options = &#123;&#125;) &#123; let pre = 0 let canRun = true let first = options.leading || false return function() &#123; if (first) &#123; fn.apply(this, arguments) first = false &#125; if (options.trailing) &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; else &#123; const now = Date.now() if (now - pre &gt; interval) &#123; if (pre) &#123; fn.apply(this, arguments) &#125; pre = now &#125; &#125; &#125;&#125; 2.3 使用123456document.querySelector('body').addEventListener('mousemove', throttle((e) =&gt; &#123; console.log(e.clientY)&#125;, 1000, &#123; leading: true, trailing: true&#125;)) 如图，对 mousemove事件节流：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（二）]]></title>
    <url>%2F2019%2F06%2F20%2FregExp2%2F</url>
    <content type="text"><![CDATA[1. Js 中关于正则的 API1.1 String 中的方法 search search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 1234var str="Mr. Blue has a blue house";console.log(str.search(/blue/i));// =&gt; 4// 注意 /i 表示对大小写忽略，所以找到了 Blue 的位置，即为 4 split split() 方法用于把一个字符串分割成字符串数组，接受的参数为字符串或正则表达式。 1234var str="How are you doing today?";var n=str.split(/\s/);console.log(n);// =&gt; ["How", "are", "you", "doing", "today?"] match match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，接受的参数为 regexp。 注意：match 返回结果的格式，与正则对象是否有修饰符 g 有关。 没有 g，返回的是标准匹配格式，即数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有 g，返回的是所有匹配的内容。 当没有匹配时，不管有无 g，都返回 null。 1234567var string = "2019/06/18";var regex1 = /\b(\d+)\b/;var regex2 = /\b(\d+)\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; ["2019", "2019", index: 0, input: "2019/06/18", groups: undefined]// =&gt; ["2019", "06", "18"] replace replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。语法为 string.replace(regexp|substr, newSubStr|function)。 replace 有两种使用形式，因为它的第二个参数，可以是字符串，也可以是函数。 当第二个参数是字符串时，我们可以用 $1,$2,...,$99 来匹配第 1-99 个分组里捕获的文本 123var result = "2,3,5".replace(/(\d+),(\d+),(\d+)/, "$3=$1+$2");console.log(result);// =&gt; "5=2+3" - 当第二个参数是函数时，在这种情况下，当匹配执行后，该函数就会执行。函数的返回值作为替换字符串。 注意：如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。下面是该函数的参数。 |参数|含义| |:---:|:---:| |`match`|匹配的子串| |`$1, $2, ...`|匹配的分组，对应于上例的`$1，$2，...`| |`index`|匹配到的子字符串在原字符串中的下标| |`input`| 被匹配的原字符串| 如下例，匹配一个四位数字，把中间两位数字变成 `**` 123456789var result = "1234 2345 3456".replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]); return `$&#123;$1&#125;**$&#123;$2&#125;`&#125;);console.log(result);// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"]// =&gt; 1**4 2**5 3**6 1.2 RegExp 中对象方法 exec exec() 方法用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.exec(str);console.log(result);// =&gt; ["Hello", index: 0, input: "Hello world!", groups: undefined] test test() 方法用于检测一个字符串是否匹配某个模式。如果字符串中有匹配的值返回 true ，否则返回 false。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.test(str);console.log(result);// =&gt; true 2. 常用正则表达式2.1 数字的千位符表示情形：把一串整数转换成千位分隔形式，例如 12345678，转换成 12,345,678 。 思路：从个位往左数起，每三位前插入一个千位分隔符，即可以想象成我们要把每三位数字前面的空 &quot;&quot;（即位置）匹配出来，并替换成千位分隔符。 做法：首先因为需要从右往左匹配，$ 是必须要有的。三位数字用 \d{3}，不确定多少组，用 (\d{3})+，所以目前为 /(\d{3})+$/g。由于替换的是位置，所以需要用到位置锚 (?=p)，即 /(?=(\d{3})+$)/g: 123var result = "12345678".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 12,345,678 但如果是 9 位数字的话， 123var result = "123456789".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; ,123,456,789 所以我们可以在匹配的位置前加一个非单词边界 \B,即 /(?=(\B\d{3})+$)/g: 123var result = "123456789".replace(/(?=(\B\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 123,456,789 2.2 模拟 trim 方法情形：去掉字符串的开头和结尾的空白符 思路：还是匹配位置，替换成 &#39;&#39; 做法： 12345function trim(str) &#123; return str.replace(/^\s+|\s+$/g, '');&#125;console.log(trim(" test ") );// =&gt; test 2.3 单词首字母大写情形：把 i&#39;m a curious babe 转化成 I&#39;m A Curious Babe 思路: 找到首字母并替换之 做法： 1234567function upperTitle(str) &#123; return str.replace(/(^|\s)\w/g, function(match) &#123; return match.toUpperCase(); &#125;)&#125;console.log(upperTitle("i'm a curious babe"));// =&gt; I'm A Curious Babe 驼峰化的思路是一样的： 12345678910function camelize (str) &#123; return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123; console.log(match, c); return c ? c.toUpperCase() : ''; &#125;);&#125;console.log(camelize('-moz-transform'));// =&gt; -m m// =&gt; -t t// =&gt; MozTransform 2.4 验证身份证情形: 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x 做法：(^\d{15}$)|(^\d{17}(\d|X|x)$) 1234var reg = /(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/;var id = '25271618827172817X';console.log(reg.test(id));// =&gt; true 2.5 验证手机号情形：以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码 做法：^1[3,4,5,7,8,9]\d{9}$ 2.6 验证邮箱情形：以大写字母 [A-Z]、小写字母 [a-z]、数字[0-9]、下滑线_、减号-及点号.开头，并需要重复一次至多次[+]; 中间必须包括 @ 符号;@ 之后需要连接大写字母 [A-Z]、小写字母 [a-z]、数字 [0-9]、下滑线 _、减号 -及点号.，并需要重复一次至多次[+];结尾必须是点号 . 连接2至4位的大小写字母 [A-Za-z]{2,4}。 做法：/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/ 123var reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/;var email = 'test-babe@163.com';console.log(reg.test(email)); 2.7 验证密码情形：密码长度 6-12 位，由数字、小写字母和大写字母组成，但必须至少包括 2 种字符。 思路1：密码长度6-12位，由 [\da-zA-Z]组成，可以写成 /^[\dA-Za-z]{6,12}$/；至少包含数字，可以写成 /(?=.*\d)/ 那么，至少包含两种字符就变成了 - 同时包含数字和小写字母 - 同时包含数字和大写字母 - 同时包含小写字母和大写字母 - 同时包含数字、小写字母和大写字母（这种情况被前三种情况包含） 做法1：所以最终写法为：/((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]{6,12}$/ 12345678var regex = /((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 思路2：至少包含两种字符的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。不能全部是数字的正则是：(?!^\d{6, 12}$)^[\da-zA-Z]{6,12}$ 做法2：所以最终写法为：/(?!^\d{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[\dA-Za-z]{6,12}$/ 12345678var regex = /(?!^\d&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程 MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（一）]]></title>
    <url>%2F2019%2F06%2F18%2FregExp1%2F</url>
    <content type="text"><![CDATA[1. 定义正则表达式通俗的讲就是按照某种规则去匹配符合条件的字符串。 在前端开发中经常能够遇到它，比如说表单验证，字符处理等。虽然功能及其强大，在几乎所有语言中都可以使用，但是其繁杂的语法使其成了许多前端同学包括我的一个痛点。 所以今天做一个总结，理解最常用的正则语法。这样下次遇到正则表达式问题时就可以自己独立解决了。 先放上核心总结： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 2. 工具正则表达式可视化工具https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24 我们可以利用这个工具辅助理解正则表达式 3. 字符匹配3.1 字符组最简单的正则表达式可以由数字或字母组成。比如说如果想在 monky 这个单词里找到 o 这个字符，就直接用 /o/ 这个正则就可以了。 123var regex = /o/;console.log( regex.test("monkey") );// =&gt; true 在正则表达式里，范围表示法使用中括号 []。例 [123] 表示匹配一个字符，它可以是 1、2、3 之一。如果需要匹配所有的数字，可以使用 [0123456789]，还可以简写成[0-9]。同理，匹配任意小写字母可以写成 [a-z]。 如果想匹配不以数字开头的字符呢，可以用排除字符组 [^]。例如[^0-9] 表示是一个除数字之外的任意一个字符。 下面是一些常用的字符组： 字符组 含义 记忆方法 \d 匹配一个数字字符，等价于 [0-9] digit \D 匹配一个非数字字符，等价于 [^0-9] \w 匹配字母、数字、下划线，等价于 [A-Za-z0-9_] word \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_] \s 匹配任何空白字符，包括空格、制表符、换页符，回车符等等，等价于 [ \f\n\r\t\v] (注意正则前面有个空格) space \S 匹配任何非空白字符，等价于 [^ \f\n\r\t\v] . 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外，等价于 [^\n\r\u2028\u2029] 注意：如果你想查找元字符本身的话，需要使用 \ 来转义，比如说查找. 和 \，就得使用 \. 和 \\。 3.2 重复比如说 \d{3} 表示 数字 必须重复三次。 下面是一些常用的重复限定符： 限定符 含义 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 3.3 贪婪匹配与惰性匹配正则表达式在匹配时，默认行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。 1234var regex = /a.*b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aabab&quot;] 以这个表达式为例：它会匹配整个字符串 aabab 。这被称为贪婪匹配。 有时我们需要惰性匹配，也就是匹配尽可能少的字符。这时候前面给出的重复限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。 1234var regex = /a.*?b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aab&quot;, &quot;ab&quot;] 下面是一些常用的惰性重复限定符： 限定符 含义 *? 重复零次或更多次，但尽可能少重复 +? 重复一次或更多次，但尽可能少重复 ?? 重复零次或一次，但尽可能少重复 {n,}? 重复n次或更多次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 3.4 分支正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 | 把不同的规则分隔开。比如说：(apple|banana|watermelon) 表示匹配 apple 或 banana 或watermelon`。 1234var regex = /apple|banana|watermelon/g;var string = &quot;would you like apple or banana?&quot;;console.log(string.match(regex));// =&gt; [&quot;apple&quot;, &quot;banana&quot;] 4. 位置匹配如图，位置(锚)是相邻字符之间的位置。 常见的位置锚有： 位置锚 含义 ^ 匹配开头，在多行匹配中匹配行开头 $ 匹配结尾，在多行匹配中匹配行结尾 \b boundary，单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置 \B 非单词边界，与 \b 相反，是 \w 与 \w、 \W 与 \W、\W 与 ^，\W 与 $ 之间的位置 (?=p) p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p（匹配的是位置） (?!p) p 是一个子模式，即 非p字符 前面的位置，或者说，该位置后面的字符不能有 p（匹配的是位置） 其可视化形式见下图： 下面两个例子，第一个是匹配以 ing 结尾的单词的前面部分(除了ing以外的部分)，第二个是匹配不以 s 和 d 开头的单词。 123456789var regex = /\b\w+(?=ing\b)/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["sing", "danc"]var regex = /\b(?!(s|d))\w+\b/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["I", "m", "while", "you", "re"] 两个例子的可视化形式见下图: 5. 分组正则中用小括号来指定分组(也叫做子表达式)。比如说 (abc)+ ，就是一个分组，小括号使 abc 成了一个整体。 5.1 分组引用对字符串使用带 () 的正则操作后，可以通过 $1, $2, ... 或者全局的 RegExp.$1, RegExp.$2, ... 来对分组数据进行引用。 12345var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date = "2019-06-18";var result = date.replace(regex, "$2/$3/$1");console.log(result);// =&gt; "06/18/2019" 等价于： 1234567var regex2 = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date2 = "2019-06-19";var result2 = date2.replace(regex2, function () &#123; return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;&#125;);console.log(result2);// =&gt; "06/19/2019" 5.2 反向引用反向引用指的是模式的后面部分引用前面已经匹配到的子字符串。语法是 \1,\2,.... ,其中 \1 表示引用的第一个子表达式，\2 表示引用的第二个子表达式，以此类推。而 \0 则表示整个表达式。 12345678var regex = /(\d&#123;3&#125;)([a-z]&#123;3&#125;)\1\2/;var string = '123abc123abc';console.log(regex.test(string));console.log(RegExp.$1);console.log(RegExp.$2);// =&gt; true// =&gt; 123// =&gt; abc 上例中，\1 表示第一个分组内容，即 123，\2 表示第二个分组内容，即 abc。 5.3 非捕获括号普通的括号都会捕获匹配数据，以便后续引用。如果我们不需要引用，为了节约内存，可以使用非捕获括号 (?:regex) 例如 (?:abc)，下图已经没有了 Group #1 的标识 6. 符号优先级当各种运算符号混杂在一起时，确定其优先级成为了一件至关重要的事。下表是常用操作符的运算优先级，优先级从高到底： 操作符描述 操作符 优先级 转义符 \ 1 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 2 量词限定符 {m}、{m,n}、{m,}、?、*、+ 3 位置和序列 ^、$、\元字符、一般字符 4 管道符(竖杠) ` ` 例 /ab?(c|de*)+|fg/，其可视化形式为： 到这里为止，正则的基本语法就讲完了。还记得开头的核心总结吗： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 是不是对这句话有了较为深入的理解。接下来的文章会介绍 Js 里一些正则的 API，并结合实例来说明一些常用正则的使用。 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[1. 定义Markdown 是一种轻量级标记语言，让作者专注于写作而不用关注样式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面（且Markdown是兼容HTML语法的）。所以用Markdown写文章是最适合不过的啦。 2. 基本语法Markdown 的语法全由一些符号所组成，其语法主要分为如下几大部分： 标题，段落，分隔线，字体，引用，图片，超链接，列表，表格，代码片段。 2.1 标题在文本前面加上 # 即可创建一级标题。同理，创建二级标题、三级标题等只需要增加 # 个数即可，Markdown 共支持六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 段落使用Markdown分段非常简单，前后至少保留一个空行即可。 123第一段文字...第二段文字... 效果： 第一段文字… 第二段文字… 2.3 分隔线三个以上的短线 即可作出分割线。 1--- 效果： 2.4 字体 倾斜：左右分别用一个*号包起来 加粗：左右分别用两个*号包起来 倾斜加粗：左右分别用三个*号包起来 删除线：左右分别用两个~~号包起来 1234*倾斜***加粗*****倾斜加粗***~~加删除线~~ 效果： 倾斜加粗倾斜加粗加删除线 2.5 引用在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt;, 三个 &gt;&gt;&gt;甚至更多 123&gt; 这是引用的内容&gt;&gt; 这是引用的内容&gt;&gt;&gt;&gt;&gt; 这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 2.6 图片1![图片alt](图片地址 &quot;图片title&quot;) 图片alt就是显示在图片显示不出来时替代的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 1![妙蛙种子](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=580eddc172d98d1076d40b371904df33/8326cffc1e178a82cfd2349df803738da977e825.jpg &quot;妙蛙种子&quot;) 效果： 注意：到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 2.7 超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 1[知乎](https://www.zhihu.com) 效果： 知乎 注意：Markdown也支持传统的HTML标签，你也可以直接写成&lt;a href=&quot;https://www.zhihu.com&quot;&gt;知乎&lt;/a&gt; 2.8 列表 无序列表无序列表用 - + * 任一开头都可以。注意：- + * 跟内容之间都要有一个空格 123- 列表内容+ 列表内容* 列表内容 效果： 列表内容 列表内容 列表内容 有序列表数字加点即可。注意：序号跟内容之间要有空格，且列表可以嵌套 1231.列表内容2.列表内容3.列表内容 效果： 1.列表内容 2.列表内容 3.列表内容2.9 表格123456789|表头|表头|表头||---|:---:|---:||内容短|内容|内容长一点||内容|内容|内容|第二行分割表头和内容。文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果： 表头 表头 表头 内容短 内容 内容长一点 内容 内容 内容 2.10 代码 单行代码：代码之间分别用一个反引号包起来 多行代码：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1`代码内容` 多行代码 多行代码 多行代码 12345```效果：`代码内容` 多行代码 多行代码 多行代码``` 3. 使用以下是常用的 markdown 工具和支持 markdown 语法的在线平台 软件 mweb 马克飞象 Mou 平台 github 简书 Stack Overflow 在线编辑器 Cmd Markdown 编辑阅读器]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
