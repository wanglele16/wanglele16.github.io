<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Js 数组乱序]]></title>
    <url>%2F2019%2F07%2F01%2Fshuffle%2F</url>
    <content type="text"><![CDATA[1. 定义数组乱序就是把数组存储值的顺序都打乱。通常我们在做抽奖系统或者发牌等游戏时，会遇到数组乱序的问题。举个例子：将 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 乱序。 2. sort 方法通常我们最快想到的方法是利用 sort。 1234567function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;console.log(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))// =&gt; [3, 5, 9, 10, 7, 6, 4, 8, 1, 2] 乍一看没问题，但是运行次数多了我们就会发现，末尾的数字为大数的概率较大，开始的数字为小数的概率较大。 我们可以验证下，10000 次随机测试，10 个位置，每个位置的平均值应该是一样的，即 (1+10)*10/2/10 = 5.5: 123456789101112131415161718192021const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(arr) &#123; return arr.sort(() =&gt; (Math.random() - 0.5))&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [48544, 48860, 55333, 56927, 56797, 53396, 53790, 56762, 58967, 60624]// =&gt; [4.8544, 4.886, 5.5333, 5.6927, 5.6797, 5.3396, 5.379, 5.6762, 5.8967, 6.0624] 可以看到，每个位置平均值有比较明显的误差。那么这是什么原因呢？ 原来，在Chrome v8引擎源码中，处理sort方法时，使用了插入排序和快速排序两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快速排序和插入排序的混合排序。 所以用 sort 方法乱序不准确的原因就在于：理想的方案是数组中每两个元素都要进行比较，这个比较有50%的交换位置概率。而在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。 3. 洗牌算法可以利用洗牌算法来进行彻底的乱序。洗牌算法的思路是： 先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置；然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换；以此类推，打乱整个数组的顺序。 1234567function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125; 这时再测试下： 12345678910111213141516171819202122232425const arr = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10]function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125;let resultArr = Array(10).fill(0)for (let i = 0; i &lt; 10000; i++) &#123; // sort 会改变原数组，必须用新数组来进行乱序 let newArr = [].concat(arr) const tmp = shuffle(newArr) resultArr.forEach((item, index) =&gt; &#123; // 不能直接改变 item 的值, item += tmp[index], 因为 forEach 不会改变原数组 resultArr[index] += tmp[index] &#125;)&#125;console.log(resultArr)const average = resultArr.map(i =&gt; i/ 10000)console.log(average)// =&gt; [55070, 54854, 54588, 55169, 55458, 54670, 55311, 54944, 55030, 54906]// =&gt; [5.507, 5.4854, 5.4588, 5.5169, 5.5458, 5.467, 5.5311, 5.4944, 5.503, 5.4906] 我们可以看到，已经是真正的乱序啦。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js 函数防抖和节流]]></title>
    <url>%2F2019%2F06%2F25%2Fthrottle%2F</url>
    <content type="text"><![CDATA[我们前端在实际开发过程中，经常会遇到如下问题： 页面的 scroll 事件 input 输入检测事件 高频点击提交 如果不做任何处理的话，页面可能会卡顿，性能较低。这时候就需要函数防抖和节流来出马啦。 1. 函数防抖1.1 定义在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 例子：电梯是在等人进入10秒后自动关闭。如果电梯进人后10s内再次有人进入，则又得等10秒钟电梯才会自动关闭。如果中间一直进人，就一直不会关闭。 1.2 代码实现思路：用定时器执行函数，判断如果存在定时器任务，则清空定时器，重新开启一个新的定时器 简易代码： 12345678910// fn 是需要执行的函数, interval 是等待时间间隔function debounce(fn, interval = 300) &#123; let timeout = null return function() &#123; clearTimeout(timeout) timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 但是这一版防抖有个缺点，就是第一次不会执行，得等到 interval 后才会执行，如果需要首次执行，可修改代码如下： 123456789101112131415// immediate 为 true 代表需要立即执行 fn, 为 false 代表不需要function debounce(fn, interval = 1000, immediate) &#123; let timeout = null let first = true return function() &#123; clearTimeout(timeout) if (immediate &amp;&amp; first) &#123; fn.apply(this, arguments) first = false &#125; timeout = setTimeout(()=&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125; 1.3 使用123document.querySelector('body').addEventListener('mousemove', debounce((e) =&gt; &#123; console.log(e.clientY)&#125;, 300, true)) 如图，对 mousemove事件防抖： 2. 函数节流2.1 定义规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 例子: 在页面滚动时，会不断地触发 scroll 事件，实际上我们不需要这么频繁地去执行函数，这是就可以设置一个间隔，比如说 300ms，在 300ms 这个时间内，scroll 内的函数只能执行一次。 2.2 代码实现思路 1：用时间轴来判断，如果事件触发时间与上一次函数执行时间之差大于规定时间，则执行一次，反之不执行 代码 1： 1234567891011// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let pre = 0 return function() &#123; const now = Date.now() if (now - pre &gt; interval) &#123; fn.apply(this, arguments) pre = now &#125; &#125;&#125; 这个函数特点是：会立刻执行，停止触发后就不会执行。 思路 2：用定时器，在定时器未执行的时间内，再次触发的函数将不再执行。 代码 2： 1234567891011121314// fn 是需要执行的函数, interval 是等待时间间隔function throttle(fn, interval = 1000) &#123; let canRun = true return function() &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; &#125; 这个函数特点是：等待 interval 时间间隔后才执行，停止触发后会再执行一次。 把思路 1 和思路 2 结合起来，用变量来控制第一次是否执行及停止触发后是否再执行一次： 123456789101112131415161718192021222324252627282930313233// options 作为第三个参数,// options.leading 为 true 时表示第一次就执行，// options.trailing 为 true 是表示停止触发时再执行一次function throttle(fn, interval = 1000, options = &#123;&#125;) &#123; let pre = 0 let canRun = true let first = options.leading || false return function() &#123; if (first) &#123; fn.apply(this, arguments) first = false &#125; if (options.trailing) &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.apply(this, arguments) canRun = true &#125;, interval) &#125; else &#123; const now = Date.now() if (now - pre &gt; interval) &#123; if (pre) &#123; fn.apply(this, arguments) &#125; pre = now &#125; &#125; &#125;&#125; 2.3 使用123456document.querySelector('body').addEventListener('mousemove', throttle((e) =&gt; &#123; console.log(e.clientY)&#125;, 1000, &#123; leading: true, trailing: true&#125;)) 如图，对 mousemove事件节流：]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（二）]]></title>
    <url>%2F2019%2F06%2F20%2FregExp2%2F</url>
    <content type="text"><![CDATA[1. Js 中关于正则的 API1.1 String 中的方法 search search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 1234var str="Mr. Blue has a blue house";console.log(str.search(/blue/i));// =&gt; 4// 注意 /i 表示对大小写忽略，所以找到了 Blue 的位置，即为 4 split split() 方法用于把一个字符串分割成字符串数组，接受的参数为字符串或正则表达式。 1234var str="How are you doing today?";var n=str.split(/\s/);console.log(n);// =&gt; ["How", "are", "you", "doing", "today?"] match match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，接受的参数为 regexp。 注意：match 返回结果的格式，与正则对象是否有修饰符 g 有关。 没有 g，返回的是标准匹配格式，即数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有 g，返回的是所有匹配的内容。 当没有匹配时，不管有无 g，都返回 null。 1234567var string = "2019/06/18";var regex1 = /\b(\d+)\b/;var regex2 = /\b(\d+)\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; ["2019", "2019", index: 0, input: "2019/06/18", groups: undefined]// =&gt; ["2019", "06", "18"] replace replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。语法为 string.replace(regexp|substr, newSubStr|function)。 replace 有两种使用形式，因为它的第二个参数，可以是字符串，也可以是函数。 当第二个参数是字符串时，我们可以用 $1,$2,...,$99 来匹配第 1-99 个分组里捕获的文本 123var result = "2,3,5".replace(/(\d+),(\d+),(\d+)/, "$3=$1+$2");console.log(result);// =&gt; "5=2+3" - 当第二个参数是函数时，在这种情况下，当匹配执行后，该函数就会执行。函数的返回值作为替换字符串。 注意：如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。下面是该函数的参数。 |参数|含义| |:---:|:---:| |`match`|匹配的子串| |`$1, $2, ...`|匹配的分组，对应于上例的`$1，$2，...`| |`index`|匹配到的子字符串在原字符串中的下标| |`input`| 被匹配的原字符串| 如下例，匹配一个四位数字，把中间两位数字变成 `**` 123456789var result = "1234 2345 3456".replace(/(\d)\d&#123;2&#125;(\d)/g, function (match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]); return `$&#123;$1&#125;**$&#123;$2&#125;`&#125;);console.log(result);// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"]// =&gt; 1**4 2**5 3**6 1.2 RegExp 中对象方法 exec exec() 方法用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.exec(str);console.log(result);// =&gt; ["Hello", index: 0, input: "Hello world!", groups: undefined] test test() 方法用于检测一个字符串是否匹配某个模式。如果字符串中有匹配的值返回 true ，否则返回 false。 12345var str="Hello world!";var patt=/Hello/g;var result=patt.test(str);console.log(result);// =&gt; true 2. 常用正则表达式2.1 数字的千位符表示情形：把一串整数转换成千位分隔形式，例如 12345678，转换成 12,345,678 。 思路：从个位往左数起，每三位前插入一个千位分隔符，即可以想象成我们要把每三位数字前面的空 &quot;&quot;（即位置）匹配出来，并替换成千位分隔符。 做法：首先因为需要从右往左匹配，$ 是必须要有的。三位数字用 \d{3}，不确定多少组，用 (\d{3})+，所以目前为 /(\d{3})+$/g。由于替换的是位置，所以需要用到位置锚 (?=p)，即 /(?=(\d{3})+$)/g: 123var result = "12345678".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 12,345,678 但如果是 9 位数字的话， 123var result = "123456789".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; ,123,456,789 所以我们可以在匹配的位置前加一个非单词边界 \B,即 /(?=(\B\d{3})+$)/g: 123var result = "123456789".replace(/(?=(\B\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; 123,456,789 2.2 模拟 trim 方法情形：去掉字符串的开头和结尾的空白符 思路：还是匹配位置，替换成 &#39;&#39; 做法： 12345function trim(str) &#123; return str.replace(/^\s+|\s+$/g, '');&#125;console.log(trim(" test ") );// =&gt; test 2.3 单词首字母大写情形：把 i&#39;m a curious babe 转化成 I&#39;m A Curious Babe 思路: 找到首字母并替换之 做法： 1234567function upperTitle(str) &#123; return str.replace(/(^|\s)\w/g, function(match) &#123; return match.toUpperCase(); &#125;)&#125;console.log(upperTitle("i'm a curious babe"));// =&gt; I'm A Curious Babe 驼峰化的思路是一样的： 12345678910function camelize (str) &#123; return str.replace(/[-_\s]+(.)?/g, function (match, c) &#123; console.log(match, c); return c ? c.toUpperCase() : ''; &#125;);&#125;console.log(camelize('-moz-transform'));// =&gt; -m m// =&gt; -t t// =&gt; MozTransform 2.4 验证身份证情形: 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x 做法：(^\d{15}$)|(^\d{17}(\d|X|x)$) 1234var reg = /(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/;var id = '25271618827172817X';console.log(reg.test(id));// =&gt; true 2.5 验证手机号情形：以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码 做法：^1[3,4,5,7,8,9]\d{9}$ 2.6 验证邮箱情形：以大写字母 [A-Z]、小写字母 [a-z]、数字[0-9]、下滑线_、减号-及点号.开头，并需要重复一次至多次[+]; 中间必须包括 @ 符号;@ 之后需要连接大写字母 [A-Z]、小写字母 [a-z]、数字 [0-9]、下滑线 _、减号 -及点号.，并需要重复一次至多次[+];结尾必须是点号 . 连接2至4位的大小写字母 [A-Za-z]{2,4}。 做法：/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/ 123var reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/;var email = 'test-babe@163.com';console.log(reg.test(email)); 2.7 验证密码情形：密码长度 6-12 位，由数字、小写字母和大写字母组成，但必须至少包括 2 种字符。 思路1：密码长度6-12位，由 [\da-zA-Z]组成，可以写成 /^[\dA-Za-z]{6,12}$/；至少包含数字，可以写成 /(?=.*\d)/ 那么，至少包含两种字符就变成了 - 同时包含数字和小写字母 - 同时包含数字和大写字母 - 同时包含小写字母和大写字母 - 同时包含数字、小写字母和大写字母（这种情况被前三种情况包含） 做法1：所以最终写法为：/((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]{6,12}$/ 12345678var regex = /((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 思路2：至少包含两种字符的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。不能全部是数字的正则是：(?!^\d{6, 12}$)^[\da-zA-Z]{6,12}$ 做法2：所以最终写法为：/(?!^\d{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[\dA-Za-z]{6,12}$/ 12345678var regex = /(?!^\d&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[\dA-Za-z]&#123;6,12&#125;$/;console.log(regex.test("1234567"));console.log(regex.test("1234567AZ"));console.log(regex.test("1234567AZx"));// false// true// true 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程 MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最常用的正则表达式（一）]]></title>
    <url>%2F2019%2F06%2F18%2FregExp1%2F</url>
    <content type="text"><![CDATA[1. 定义正则表达式通俗的讲就是按照某种规则去匹配符合条件的字符串。 在前端开发中经常能够遇到它，比如说表单验证，字符处理等。虽然功能及其强大，在几乎所有语言中都可以使用，但是其繁杂的语法使其成了许多前端同学包括我的一个痛点。 所以今天做一个总结，理解最常用的正则语法。这样下次遇到正则表达式问题时就可以自己独立解决了。 先放上核心总结： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 2. 工具正则表达式可视化工具https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24 我们可以利用这个工具辅助理解正则表达式 3. 字符匹配3.1 字符组最简单的正则表达式可以由数字或字母组成。比如说如果想在 monky 这个单词里找到 o 这个字符，就直接用 /o/ 这个正则就可以了。 123var regex = /o/;console.log( regex.test("monkey") );// =&gt; true 在正则表达式里，范围表示法使用中括号 []。例 [123] 表示匹配一个字符，它可以是 1、2、3 之一。如果需要匹配所有的数字，可以使用 [0123456789]，还可以简写成[0-9]。同理，匹配任意小写字母可以写成 [a-z]。 如果想匹配不以数字开头的字符呢，可以用排除字符组 [^]。例如[^0-9] 表示是一个除数字之外的任意一个字符。 下面是一些常用的字符组： 字符组 含义 记忆方法 \d 匹配一个数字字符，等价于 [0-9] digit \D 匹配一个非数字字符，等价于 [^0-9] \w 匹配字母、数字、下划线，等价于 [A-Za-z0-9_] word \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_] \s 匹配任何空白字符，包括空格、制表符、换页符，回车符等等，等价于 [ \f\n\r\t\v] (注意正则前面有个空格) space \S 匹配任何非空白字符，等价于 [^ \f\n\r\t\v] . 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外，等价于 [^\n\r\u2028\u2029] 注意：如果你想查找元字符本身的话，需要使用 \ 来转义，比如说查找. 和 \，就得使用 \. 和 \\。 3.2 重复比如说 \d{3} 表示 数字 必须重复三次。 下面是一些常用的重复限定符： 限定符 含义 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 3.3 贪婪匹配与惰性匹配正则表达式在匹配时，默认行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。 1234var regex = /a.*b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aabab&quot;] 以这个表达式为例：它会匹配整个字符串 aabab 。这被称为贪婪匹配。 有时我们需要惰性匹配，也就是匹配尽可能少的字符。这时候前面给出的重复限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。 1234var regex = /a.*?b/g;var string = &quot;aabab&quot;;console.log(string.match(regex) );// [&quot;aab&quot;, &quot;ab&quot;] 下面是一些常用的惰性重复限定符： 限定符 含义 *? 重复零次或更多次，但尽可能少重复 +? 重复一次或更多次，但尽可能少重复 ?? 重复零次或一次，但尽可能少重复 {n,}? 重复n次或更多次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 3.4 分支正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 | 把不同的规则分隔开。比如说：(apple|banana|watermelon) 表示匹配 apple 或 banana 或watermelon`。 1234var regex = /apple|banana|watermelon/g;var string = &quot;would you like apple or banana?&quot;;console.log(string.match(regex));// =&gt; [&quot;apple&quot;, &quot;banana&quot;] 4. 位置匹配如图，位置(锚)是相邻字符之间的位置。 常见的位置锚有： 位置锚 含义 ^ 匹配开头，在多行匹配中匹配行开头 $ 匹配结尾，在多行匹配中匹配行结尾 \b boundary，单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置 \B 非单词边界，与 \b 相反，是 \w 与 \w、 \W 与 \W、\W 与 ^，\W 与 $ 之间的位置 (?=p) p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p（匹配的是位置） (?!p) p 是一个子模式，即 非p字符 前面的位置，或者说，该位置后面的字符不能有 p（匹配的是位置） 其可视化形式见下图： 下面两个例子，第一个是匹配以 ing 结尾的单词的前面部分(除了ing以外的部分)，第二个是匹配不以 s 和 d 开头的单词。 123456789var regex = /\b\w+(?=ing\b)/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["sing", "danc"]var regex = /\b(?!(s|d))\w+\b/g;var string = "I'm singing while you're dancing.";console.log(string.match(regex));// ["I", "m", "while", "you", "re"] 两个例子的可视化形式见下图: 5. 分组正则中用小括号来指定分组(也叫做子表达式)。比如说 (abc)+ ，就是一个分组，小括号使 abc 成了一个整体。 5.1 分组引用对字符串使用带 () 的正则操作后，可以通过 $1, $2, ... 或者全局的 RegExp.$1, RegExp.$2, ... 来对分组数据进行引用。 12345var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date = "2019-06-18";var result = date.replace(regex, "$2/$3/$1");console.log(result);// =&gt; "06/18/2019" 等价于： 1234567var regex2 = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var date2 = "2019-06-19";var result2 = date2.replace(regex2, function () &#123; return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;&#125;);console.log(result2);// =&gt; "06/19/2019" 5.2 反向引用反向引用指的是模式的后面部分引用前面已经匹配到的子字符串。语法是 \1,\2,.... ,其中 \1 表示引用的第一个子表达式，\2 表示引用的第二个子表达式，以此类推。而 \0 则表示整个表达式。 12345678var regex = /(\d&#123;3&#125;)([a-z]&#123;3&#125;)\1\2/;var string = '123abc123abc';console.log(regex.test(string));console.log(RegExp.$1);console.log(RegExp.$2);// =&gt; true// =&gt; 123// =&gt; abc 上例中，\1 表示第一个分组内容，即 123，\2 表示第二个分组内容，即 abc。 5.3 非捕获括号普通的括号都会捕获匹配数据，以便后续引用。如果我们不需要引用，为了节约内存，可以使用非捕获括号 (?:regex) 例如 (?:abc)，下图已经没有了 Group #1 的标识 6. 符号优先级当各种运算符号混杂在一起时，确定其优先级成为了一件至关重要的事。下表是常用操作符的运算优先级，优先级从高到底： 操作符描述 操作符 优先级 转义符 \ 1 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 2 量词限定符 {m}、{m,n}、{m,}、?、*、+ 3 位置和序列 ^、$、\元字符、一般字符 4 管道符(竖杠) ` ` 例 /ab?(c|de*)+|fg/，其可视化形式为： 到这里为止，正则的基本语法就讲完了。还记得开头的核心总结吗： 正则表达式是匹配模式，要么匹配字符，要么匹配位置 是不是对这句话有了较为深入的理解。接下来的文章会介绍 Js 里一些正则的 API，并结合实例来说明一些常用正则的使用。 主要参考来源： 正则表达式教程 JavaScript 正则表达式迷你书 正则表达式30分钟入门教程]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>regExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[1. 定义Markdown 是一种轻量级标记语言，让作者专注于写作而不用关注样式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面（且Markdown是兼容HTML语法的）。所以用Markdown写文章是最适合不过的啦。 2. 基本语法Markdown 的语法全由一些符号所组成，其语法主要分为如下几大部分： 标题，段落，分隔线，字体，引用，图片，超链接，列表，表格，代码片段。 2.1 标题在文本前面加上 # 即可创建一级标题。同理，创建二级标题、三级标题等只需要增加 # 个数即可，Markdown 共支持六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 段落使用Markdown分段非常简单，前后至少保留一个空行即可。 123第一段文字...第二段文字... 效果： 第一段文字… 第二段文字… 2.3 分隔线三个以上的短线 即可作出分割线。 1--- 效果： 2.4 字体 倾斜：左右分别用一个*号包起来 加粗：左右分别用两个*号包起来 倾斜加粗：左右分别用三个*号包起来 删除线：左右分别用两个~~号包起来 1234*倾斜***加粗*****倾斜加粗***~~加删除线~~ 效果： 倾斜加粗倾斜加粗加删除线 2.5 引用在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt;, 三个 &gt;&gt;&gt;甚至更多 123&gt; 这是引用的内容&gt;&gt; 这是引用的内容&gt;&gt;&gt;&gt;&gt; 这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 2.6 图片1![图片alt](图片地址 &quot;图片title&quot;) 图片alt就是显示在图片显示不出来时替代的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 1![妙蛙种子](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=580eddc172d98d1076d40b371904df33/8326cffc1e178a82cfd2349df803738da977e825.jpg &quot;妙蛙种子&quot;) 效果： 注意：到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 2.7 超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 1[知乎](https://www.zhihu.com) 效果： 知乎 注意：Markdown也支持传统的HTML标签，你也可以直接写成&lt;a href=&quot;https://www.zhihu.com&quot;&gt;知乎&lt;/a&gt; 2.8 列表 无序列表无序列表用 - + * 任一开头都可以。注意：- + * 跟内容之间都要有一个空格 123- 列表内容+ 列表内容* 列表内容 效果： 列表内容 列表内容 列表内容 有序列表数字加点即可。注意：序号跟内容之间要有空格，且列表可以嵌套 1231.列表内容2.列表内容3.列表内容 效果： 1.列表内容 2.列表内容 3.列表内容2.9 表格123456789|表头|表头|表头||---|:---:|---:||内容短|内容|内容长一点||内容|内容|内容|第二行分割表头和内容。文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果： 表头 表头 表头 内容短 内容 内容长一点 内容 内容 内容 2.10 代码 单行代码：代码之间分别用一个反引号包起来 多行代码：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1`代码内容` 多行代码 多行代码 多行代码 12345```效果：`代码内容` 多行代码 多行代码 多行代码``` 3. 使用以下是常用的 markdown 工具和支持 markdown 语法的在线平台 软件 mweb 马克飞象 Mou 平台 github 简书 Stack Overflow 在线编辑器 Cmd Markdown 编辑阅读器]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
